// Code generated by Firebird. DO NOT EDIT.
package generated

import (
	"context"
	"database/sql"
	"fmt"
	"log/slog"

	"github.com/go-playground/validator/v10"
	"{{ .ModulePath }}/internal/db"
	"{{ .ModulePath }}/internal/dto"
	"{{ .ModulePath }}/internal/repositories"
	"{{ .ModulePath }}/internal/services"
{{- if eq .PrimaryKeyType "uuid.UUID" }}
	"github.com/google/uuid"
{{- end }}
)

// {{ .ModelName }}ServiceBase provides generated CRUD operations
type {{ .ModelName }}ServiceBase struct {
	{{ .RepoFieldName }} repositories.{{ .ModelName }}Repository
	DB                   *db.DB
	Logger               *slog.Logger
	Validator            *validator.Validate
}

// Create creates a new {{ .ModelName }}
func (s *{{ .ModelName }}ServiceBase) Create(ctx context.Context, input dto.Create{{ .ModelName }}Input) (*dto.{{ .ModelName }}Response, error) {
	s.Logger.InfoContext(ctx, "creating {{ .ModelNameLower }}")

	// Validate input structure
	if err := s.Validator.Struct(input); err != nil {
		s.Logger.WarnContext(ctx, "validation failed",
			slog.Any("errors", err),
		)
		return nil, services.NewValidationError(err)
	}

	// Convert DTO to DB params
	params := toCreate{{ .ModelName }}Params(input)

	// Create via repository
	model, err := s.{{ .RepoFieldName }}.Create(ctx, params)
	if err != nil {
		s.Logger.ErrorContext(ctx, "failed to create {{ .ModelNameLower }}",
			slog.String("error", err.Error()),
		)
		return nil, fmt.Errorf("create {{ .ModelNameLower }}: %w", err)
	}

	s.Logger.InfoContext(ctx, "{{ .ModelNameLower }} created",
		slog.Any("id", model.ID),
	)

	return dto.From{{ .ModelName }}(model), nil
}

// GetByID retrieves a {{ .ModelName }} by ID
func (s *{{ .ModelName }}ServiceBase) GetByID(ctx context.Context, id {{ .PrimaryKeyType }}) (*dto.{{ .ModelName }}Response, error) {
	model, err := s.{{ .RepoFieldName }}.GetByID(ctx, id)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, services.ErrNotFound
		}
		s.Logger.ErrorContext(ctx, "failed to get {{ .ModelNameLower }}",
			slog.Any("id", id),
			slog.String("error", err.Error()),
		)
		return nil, fmt.Errorf("get {{ .ModelNameLower }}: %w", err)
	}

	return dto.From{{ .ModelName }}(model), nil
}

// List retrieves paginated {{ .ModelName }}s
func (s *{{ .ModelName }}ServiceBase) List(ctx context.Context, page services.Pagination) (*services.ListResult[*dto.{{ .ModelName }}Response], error) {
	// Get items
	models, err := s.{{ .RepoFieldName }}.ListPaginated(ctx, int32(page.PerPage), int32(page.Offset()))
	if err != nil {
		s.Logger.ErrorContext(ctx, "failed to list {{ .ModelNameLower }}s",
			slog.String("error", err.Error()),
		)
		return nil, fmt.Errorf("list {{ .ModelNameLower }}s: %w", err)
	}

	// Get total count
	total, err := s.{{ .RepoFieldName }}.Count(ctx)
	if err != nil {
		s.Logger.ErrorContext(ctx, "failed to count {{ .ModelNameLower }}s",
			slog.String("error", err.Error()),
		)
		return nil, fmt.Errorf("count {{ .ModelNameLower }}s: %w", err)
	}

	// Convert to DTOs
	responses := dto.From{{ .ModelName }}List(models)

	return services.NewListResult(responses, total, page), nil
}

// Update updates a {{ .ModelName }}
func (s *{{ .ModelName }}ServiceBase) Update(ctx context.Context, id {{ .PrimaryKeyType }}, input dto.Update{{ .ModelName }}Input) (*dto.{{ .ModelName }}Response, error) {
	s.Logger.InfoContext(ctx, "updating {{ .ModelNameLower }}",
		slog.Any("id", id),
	)

	// Validate input structure
	if err := s.Validator.Struct(input); err != nil {
		s.Logger.WarnContext(ctx, "validation failed",
			slog.Any("errors", err),
		)
		return nil, services.NewValidationError(err)
	}

	// Convert DTO to DB params
	params := toUpdate{{ .ModelName }}Params(id, input)

	// Update via repository
	model, err := s.{{ .RepoFieldName }}.Update(ctx, params)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, services.ErrNotFound
		}
		s.Logger.ErrorContext(ctx, "failed to update {{ .ModelNameLower }}",
			slog.Any("id", id),
			slog.String("error", err.Error()),
		)
		return nil, fmt.Errorf("update {{ .ModelNameLower }}: %w", err)
	}

	s.Logger.InfoContext(ctx, "{{ .ModelNameLower }} updated",
		slog.Any("id", id),
	)

	return dto.From{{ .ModelName }}(model), nil
}

// Delete deletes a {{ .ModelName }}
func (s *{{ .ModelName }}ServiceBase) Delete(ctx context.Context, id {{ .PrimaryKeyType }}) error {
	s.Logger.InfoContext(ctx, "deleting {{ .ModelNameLower }}",
		slog.Any("id", id),
	)

	err := s.{{ .RepoFieldName }}.Delete(ctx, id)
	if err != nil {
		s.Logger.ErrorContext(ctx, "failed to delete {{ .ModelNameLower }}",
			slog.Any("id", id),
			slog.String("error", err.Error()),
		)
		return fmt.Errorf("delete {{ .ModelNameLower }}: %w", err)
	}

	s.Logger.InfoContext(ctx, "{{ .ModelNameLower }} deleted",
		slog.Any("id", id),
	)

	return nil
}
{{- if .SoftDeletes }}

// Restore restores a soft-deleted {{ .ModelName }}
func (s *{{ .ModelName }}ServiceBase) Restore(ctx context.Context, id {{ .PrimaryKeyType }}) error {
	s.Logger.InfoContext(ctx, "restoring {{ .ModelNameLower }}",
		slog.Any("id", id),
	)

	err := s.{{ .RepoFieldName }}.Restore(ctx, id)
	if err != nil {
		s.Logger.ErrorContext(ctx, "failed to restore {{ .ModelNameLower }}",
			slog.Any("id", id),
			slog.String("error", err.Error()),
		)
		return fmt.Errorf("restore {{ .ModelNameLower }}: %w", err)
	}

	s.Logger.InfoContext(ctx, "{{ .ModelNameLower }} restored",
		slog.Any("id", id),
	)

	return nil
}
{{- end }}

// DTO converter functions (private)

func toCreate{{ .ModelName }}Params(input dto.Create{{ .ModelName }}Input) db.Create{{ .ModelName }}Params {
	return db.Create{{ .ModelName }}Params{
{{- range .CreateFields }}
		{{ .DBField }}: input.{{ .DTOField }},
{{- end }}
	}
}

func toUpdate{{ .ModelName }}Params(id {{ .PrimaryKeyType }}, input dto.Update{{ .ModelName }}Input) db.Update{{ .ModelName }}Params {
	params := db.Update{{ .ModelName }}Params{
		ID: id,
	}

	// Only set fields that are not nil (partial updates)
{{- range .UpdateFields }}
	if input.{{ .DTOField }} != nil {
		params.{{ .DBField }} = *input.{{ .DTOField }}
	}
{{- end }}

	return params
}
