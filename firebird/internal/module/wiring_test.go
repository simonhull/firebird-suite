package module

import (
	"context"
	"os"
	"path/filepath"
	"strings"
	"testing"
)

// Test helper functions

// setupTestProject creates a temporary project structure
func setupTestProject(t *testing.T) string {
	t.Helper()

	tmpDir := t.TempDir()

	// Create internal/modules directory
	modulesDir := filepath.Join(tmpDir, "internal", "modules")
	if err := os.MkdirAll(modulesDir, 0755); err != nil {
		t.Fatalf("failed to create modules dir: %v", err)
	}

	// Create firebird.yml
	firebirdYML := `project:
  name: "test-project"
  module: "github.com/test/project"

modules: {}
`
	if err := os.WriteFile(filepath.Join(tmpDir, "firebird.yml"), []byte(firebirdYML), 0644); err != nil {
		t.Fatalf("failed to create firebird.yml: %v", err)
	}

	return tmpDir
}

// Test 1: GenerateRegistry
func TestWiringGenerator_GenerateRegistry(t *testing.T) {
	projectPath := setupTestProject(t)
	gen := NewWiringGenerator(projectPath, "github.com/test/project")

	// Generate registry
	ops, err := gen.GenerateRegistry()
	if err != nil {
		t.Fatalf("GenerateRegistry failed: %v", err)
	}

	// Execute operations
	for _, op := range ops {
		if err := op.Execute(context.Background()); err != nil {
			t.Fatalf("Execute failed: %v", err)
		}
	}

	// Verify file exists
	registryPath := filepath.Join(projectPath, "internal", "modules", "registry.go")
	if _, err := os.Stat(registryPath); os.IsNotExist(err) {
		t.Fatal("registry.go was not created")
	}

	// Verify content
	content, err := os.ReadFile(registryPath)
	if err != nil {
		t.Fatalf("failed to read registry.go: %v", err)
	}

	requiredStrings := []string{
		"package modules",
		"type ModuleRegistry struct",
		"func NewModuleRegistry()",
		"func (r *ModuleRegistry) Register(",
		"func (r *ModuleRegistry) Get(",
		"func (r *ModuleRegistry) MustGet(",
		"func (r *ModuleRegistry) Has(",
	}

	for _, required := range requiredStrings {
		if !strings.Contains(string(content), required) {
			t.Errorf("registry.go missing required string: %q", required)
		}
	}
}

// Test 2: GenerateModuleWiring
func TestWiringGenerator_GenerateModuleWiring(t *testing.T) {
	projectPath := setupTestProject(t)
	gen := NewWiringGenerator(projectPath, "github.com/test/project")

	// Generate module wiring
	ops, err := gen.GenerateModuleWiring("falcon", "1.0.0")
	if err != nil {
		t.Fatalf("GenerateModuleWiring failed: %v", err)
	}

	// Execute operations
	for _, op := range ops {
		if err := op.Execute(context.Background()); err != nil {
			t.Fatalf("Execute failed: %v", err)
		}
	}

	// Verify file exists
	wiringPath := filepath.Join(projectPath, "internal", "modules", "wiring_falcon.go")
	if _, err := os.Stat(wiringPath); os.IsNotExist(err) {
		t.Fatal("wiring_falcon.go was not created")
	}

	// Verify content
	content, err := os.ReadFile(wiringPath)
	if err != nil {
		t.Fatalf("failed to read wiring_falcon.go: %v", err)
	}

	requiredStrings := []string{
		"package modules",
		"// Code generated by Firebird module: falcon v1.0.0",
		"func InitFalcon(",
		"db *sql.DB",
		"cfg *config.Config",
		"registry *ModuleRegistry",
	}

	for _, required := range requiredStrings {
		if !strings.Contains(string(content), required) {
			t.Errorf("wiring_falcon.go missing required string: %q", required)
		}
	}
}

// Test 3: GenerateModuleWiring with underscores
func TestWiringGenerator_GenerateModuleWiring_WithUnderscores(t *testing.T) {
	projectPath := setupTestProject(t)
	gen := NewWiringGenerator(projectPath, "github.com/test/project")

	// Generate module wiring for module with underscore
	ops, err := gen.GenerateModuleWiring("falcon_auth", "1.0.0")
	if err != nil {
		t.Fatalf("GenerateModuleWiring failed: %v", err)
	}

	// Execute operations
	for _, op := range ops {
		if err := op.Execute(context.Background()); err != nil {
			t.Fatalf("Execute failed: %v", err)
		}
	}

	// Verify file exists
	wiringPath := filepath.Join(projectPath, "internal", "modules", "wiring_falcon_auth.go")
	if _, err := os.Stat(wiringPath); os.IsNotExist(err) {
		t.Fatal("wiring_falcon_auth.go was not created")
	}

	// Verify content has PascalCase function name
	content, err := os.ReadFile(wiringPath)
	if err != nil {
		t.Fatalf("failed to read wiring_falcon_auth.go: %v", err)
	}

	if !strings.Contains(string(content), "func InitFalconAuth(") {
		t.Error("InitFalconAuth function not found (should be PascalCase)")
	}
}

// Test 4: RegenerateOrchestrator with no modules
func TestWiringGenerator_RegenerateOrchestrator_NoModules(t *testing.T) {
	projectPath := setupTestProject(t)
	gen := NewWiringGenerator(projectPath, "github.com/test/project")

	// Regenerate orchestrator
	ops, err := gen.RegenerateOrchestrator()
	if err != nil {
		t.Fatalf("RegenerateOrchestrator failed: %v", err)
	}

	// Execute operations
	for _, op := range ops {
		if err := op.Execute(context.Background()); err != nil {
			t.Fatalf("Execute failed: %v", err)
		}
	}

	// Verify file exists
	orchestratorPath := filepath.Join(projectPath, "internal", "modules", "wiring_modules.go")
	if _, err := os.Stat(orchestratorPath); os.IsNotExist(err) {
		t.Fatal("wiring_modules.go was not created")
	}

	// Verify content
	content, err := os.ReadFile(orchestratorPath)
	if err != nil {
		t.Fatalf("failed to read wiring_modules.go: %v", err)
	}

	requiredStrings := []string{
		"package modules",
		"func InitModules(",
		"registry := NewModuleRegistry()",
	}

	for _, required := range requiredStrings {
		if !strings.Contains(string(content), required) {
			t.Errorf("wiring_modules.go missing required string: %q", required)
		}
	}
}

// Test 5: RegenerateOrchestrator with modules
func TestWiringGenerator_RegenerateOrchestrator_WithModules(t *testing.T) {
	projectPath := setupTestProject(t)

	// Add some modules to firebird.yml
	firebirdYML := `project:
  name: "test-project"
  module: "github.com/test/project"

modules:
  falcon:
    version: "1.0.0"
    config:
      jwt_secret: "secret123"
  owl:
    version: "0.5.0"
    config:
      docs_path: "/docs"
`
	if err := os.WriteFile(filepath.Join(projectPath, "firebird.yml"), []byte(firebirdYML), 0644); err != nil {
		t.Fatalf("failed to update firebird.yml: %v", err)
	}

	gen := NewWiringGenerator(projectPath, "github.com/test/project")

	// Regenerate orchestrator
	ops, err := gen.RegenerateOrchestrator()
	if err != nil {
		t.Fatalf("RegenerateOrchestrator failed: %v", err)
	}

	// Execute operations
	for _, op := range ops {
		if err := op.Execute(context.Background()); err != nil {
			t.Fatalf("Execute failed: %v", err)
		}
	}

	// Verify file exists
	orchestratorPath := filepath.Join(projectPath, "internal", "modules", "wiring_modules.go")
	if _, err := os.Stat(orchestratorPath); os.IsNotExist(err) {
		t.Fatal("wiring_modules.go was not created")
	}

	// Verify content
	content, err := os.ReadFile(orchestratorPath)
	if err != nil {
		t.Fatalf("failed to read wiring_modules.go: %v", err)
	}

	requiredStrings := []string{
		"package modules",
		"func InitModules(",
		"InitFalcon(db, cfg, registry)",
		"InitOwl(db, cfg, registry)",
	}

	for _, required := range requiredStrings {
		if !strings.Contains(string(content), required) {
			t.Errorf("wiring_modules.go missing required string: %q", required)
		}
	}

	// Verify modules are sorted alphabetically (falcon before owl)
	falconIdx := strings.Index(string(content), "InitFalcon")
	owlIdx := strings.Index(string(content), "InitOwl")
	if falconIdx > owlIdx {
		t.Error("Modules should be sorted alphabetically (falcon before owl)")
	}
}

// Test 6: firebird.yml AddModule
func TestFirebirdConfig_AddModule(t *testing.T) {
	projectPath := setupTestProject(t)
	configPath := filepath.Join(projectPath, "firebird.yml")

	// Add module
	err := AddModule(configPath, "falcon", "1.0.0", map[string]interface{}{
		"jwt_secret":   "secret123",
		"token_expiry": "24h",
	})
	if err != nil {
		t.Fatalf("AddModule failed: %v", err)
	}

	// Load and verify
	cfg, err := LoadFirebirdConfig(configPath)
	if err != nil {
		t.Fatalf("LoadFirebirdConfig failed: %v", err)
	}

	if cfg.Modules["falcon"].Version != "1.0.0" {
		t.Errorf("Expected version 1.0.0, got %s", cfg.Modules["falcon"].Version)
	}

	if cfg.Modules["falcon"].Config["jwt_secret"] != "secret123" {
		t.Error("Config not saved correctly")
	}
}

// Test 7: firebird.yml RemoveModule
func TestFirebirdConfig_RemoveModule(t *testing.T) {
	projectPath := setupTestProject(t)
	configPath := filepath.Join(projectPath, "firebird.yml")

	// Add module first
	AddModule(configPath, "falcon", "1.0.0", nil)

	// Remove module
	err := RemoveModule(configPath, "falcon")
	if err != nil {
		t.Fatalf("RemoveModule failed: %v", err)
	}

	// Verify removed
	cfg, err := LoadFirebirdConfig(configPath)
	if err != nil {
		t.Fatalf("LoadFirebirdConfig failed: %v", err)
	}

	if _, exists := cfg.Modules["falcon"]; exists {
		t.Error("Module was not removed")
	}
}

// Test 8: toPascalCase Helper Function
func TestToPascalCase(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{"falcon", "Falcon"},
		{"falcon_auth", "FalconAuth"},
		{"api_key", "ApiKey"},
		{"owl", "Owl"},
		{"my_module_name", "MyModuleName"},
	}

	for _, tt := range tests {
		t.Run(tt.input, func(t *testing.T) {
			result := toPascalCase(tt.input)
			if result != tt.expected {
				t.Errorf("toPascalCase(%q) = %q, want %q", tt.input, result, tt.expected)
			}
		})
	}
}

// Test 9: Full Workflow - Generate All Files
func TestWiringGenerator_FullWorkflow(t *testing.T) {
	projectPath := setupTestProject(t)
	gen := NewWiringGenerator(projectPath, "github.com/test/project")

	// Step 1: Generate registry
	ops, err := gen.GenerateRegistry()
	if err != nil {
		t.Fatalf("GenerateRegistry failed: %v", err)
	}
	for _, op := range ops {
		if err := op.Execute(context.Background()); err != nil {
			t.Fatalf("Execute registry failed: %v", err)
		}
	}

	// Step 2: Add modules to firebird.yml
	configPath := filepath.Join(projectPath, "firebird.yml")
	if err := AddModule(configPath, "falcon", "1.0.0", nil); err != nil {
		t.Fatalf("AddModule(falcon) failed: %v", err)
	}
	if err := AddModule(configPath, "owl", "0.5.0", nil); err != nil {
		t.Fatalf("AddModule(owl) failed: %v", err)
	}

	// Step 3: Generate module wiring
	ops, err = gen.GenerateModuleWiring("falcon", "1.0.0")
	if err != nil {
		t.Fatalf("GenerateModuleWiring(falcon) failed: %v", err)
	}
	for _, op := range ops {
		if err := op.Execute(context.Background()); err != nil {
			t.Fatalf("Execute falcon wiring failed: %v", err)
		}
	}

	ops, err = gen.GenerateModuleWiring("owl", "0.5.0")
	if err != nil {
		t.Fatalf("GenerateModuleWiring(owl) failed: %v", err)
	}
	for _, op := range ops {
		if err := op.Execute(context.Background()); err != nil {
			t.Fatalf("Execute owl wiring failed: %v", err)
		}
	}

	// Step 4: Regenerate orchestrator
	ops, err = gen.RegenerateOrchestrator()
	if err != nil {
		t.Fatalf("RegenerateOrchestrator failed: %v", err)
	}
	for _, op := range ops {
		if err := op.Execute(context.Background()); err != nil {
			t.Fatalf("Execute orchestrator failed: %v", err)
		}
	}

	// Verify all files exist
	files := []string{
		"internal/modules/registry.go",
		"internal/modules/wiring_falcon.go",
		"internal/modules/wiring_owl.go",
		"internal/modules/wiring_modules.go",
	}

	for _, file := range files {
		fullPath := filepath.Join(projectPath, file)
		if _, err := os.Stat(fullPath); os.IsNotExist(err) {
			t.Errorf("File not created: %s", file)
		}
	}

	// Verify orchestrator calls both init functions
	orchestratorContent, _ := os.ReadFile(filepath.Join(projectPath, "internal/modules/wiring_modules.go"))
	if !strings.Contains(string(orchestratorContent), "InitFalcon") {
		t.Error("Orchestrator missing InitFalcon call")
	}
	if !strings.Contains(string(orchestratorContent), "InitOwl") {
		t.Error("Orchestrator missing InitOwl call")
	}
}
