// Code generated by Firebird. Edit freely - this file is yours.
package handlers

import (
	"encoding/json"
	"net/http"

	"{{ .ModulePath }}/internal/dto"
	"{{ .ModulePath }}/internal/services"
	"{{ .ModulePath }}/internal/validation"
{{- if eq .PrimaryKeyType "uuid.UUID" }}
	"github.com/google/uuid"
{{- end }}
)

// {{ .ModelName }}Handler handles HTTP requests for {{ .ModelName }} resources
type {{ .ModelName }}Handler struct {
	service   services.{{ .ModelName }}Service
	validator *validation.Validate
}

// New{{ .ModelName }}Handler creates a new {{ .ModelName }} handler
func New{{ .ModelName }}Handler(service services.{{ .ModelName }}Service) *{{ .ModelName }}Handler {
	return &{{ .ModelName }}Handler{
		service:   service,
		validator: validation.New(),
	}
}

// Index handles GET /{{ .ModelPlural }} - List all {{ .ModelPlural }} with pagination
func (h *{{ .ModelName }}Handler) Index(w http.ResponseWriter, r *http.Request) {
	pagination := ParsePagination(r)

	result, err := h.service.List(r.Context(), pagination)
	if err != nil {
		RespondServiceError(w, err)
		return
	}

	meta := map[string]interface{}{
		"page":        result.Page,
		"per_page":    result.PerPage,
		"total":       result.Total,
		"total_pages": result.TotalPages,
	}

	RespondSuccessWithMeta(w, http.StatusOK, result.Items, meta)
}

// Store handles POST /{{ .ModelPlural }} - Create new {{ .ModelNameLower }}
func (h *{{ .ModelName }}Handler) Store(w http.ResponseWriter, r *http.Request) {
	var req dto.Create{{ .ModelName }}Input
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		RespondError(w, http.StatusBadRequest, "Invalid JSON", "invalid_json")
		return
	}

	if err := h.validator.Struct(req); err != nil {
		RespondValidationError(w, err)
		return
	}

	{{ .ModelNameLower }}, err := h.service.Create(r.Context(), req)
	if err != nil {
		RespondServiceError(w, err)
		return
	}

	RespondSuccess(w, http.StatusCreated, {{ .ModelNameLower }})
}

// Show handles GET /{{ .ModelPlural }}/{id} - Get single {{ .ModelNameLower }}
{{- if .HasAPILoadableRelationships }}
// Supports ?include=relationship1,relationship2 for eager loading
{{- end }}
func (h *{{ .ModelName }}Handler) Show(w http.ResponseWriter, r *http.Request) {
	id, err := GetPath{{ if eq .PrimaryKeyType "uuid.UUID" }}UUID{{ else }}Int64{{ end }}(r, "id")
	if err != nil {
		RespondError(w, http.StatusBadRequest, "Invalid ID", "invalid_id")
		return
	}

{{- if .HasAPILoadableRelationships }}
	// Check for relationship includes
	includes := ParseIncludes(r)

	var {{ .ModelNameLower }} *dto.{{ .ModelName }}Response
	if len(includes) > 0 {
		{{ .ModelNameLower }}, err = h.service.GetByIDWithIncludes(r.Context(), id, includes)
	} else {
		{{ .ModelNameLower }}, err = h.service.GetByID(r.Context(), id)
	}

	if err != nil {
		RespondServiceError(w, err)
		return
	}
{{- else }}
	{{ .ModelNameLower }}, err := h.service.GetByID(r.Context(), id)
	if err != nil {
		RespondServiceError(w, err)
		return
	}
{{- end }}

	RespondSuccess(w, http.StatusOK, {{ .ModelNameLower }})
}

// Update handles PUT /{{ .ModelPlural }}/{id} - Update {{ .ModelNameLower }}
func (h *{{ .ModelName }}Handler) Update(w http.ResponseWriter, r *http.Request) {
	id, err := GetPath{{ if eq .PrimaryKeyType "uuid.UUID" }}UUID{{ else }}Int64{{ end }}(r, "id")
	if err != nil {
		RespondError(w, http.StatusBadRequest, "Invalid ID", "invalid_id")
		return
	}

	var req dto.Update{{ .ModelName }}Input
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		RespondError(w, http.StatusBadRequest, "Invalid JSON", "invalid_json")
		return
	}

	if err := h.validator.Struct(req); err != nil {
		RespondValidationError(w, err)
		return
	}

	{{ .ModelNameLower }}, err := h.service.Update(r.Context(), id, req)
	if err != nil {
		RespondServiceError(w, err)
		return
	}

	RespondSuccess(w, http.StatusOK, {{ .ModelNameLower }})
}

// Destroy handles DELETE /{{ .ModelPlural }}/{id} - {{ if .HasSoftDelete }}Soft delete{{ else }}Delete{{ end }} {{ .ModelNameLower }}
func (h *{{ .ModelName }}Handler) Destroy(w http.ResponseWriter, r *http.Request) {
	id, err := GetPath{{ if eq .PrimaryKeyType "uuid.UUID" }}UUID{{ else }}Int64{{ end }}(r, "id")
	if err != nil {
		RespondError(w, http.StatusBadRequest, "Invalid ID", "invalid_id")
		return
	}

{{ if .HasSoftDelete }}	// Soft delete (sets deleted_at timestamp)
{{ end }}	err = h.service.Delete(r.Context(), id)
	if err != nil {
		RespondServiceError(w, err)
		return
	}

	w.WriteHeader(http.StatusNoContent)
}

// TODO: Add custom handlers here
// Example:
//
// func (h *{{ .ModelName }}Handler) CustomAction(w http.ResponseWriter, r *http.Request) {
//     // Your custom handler logic
// }
