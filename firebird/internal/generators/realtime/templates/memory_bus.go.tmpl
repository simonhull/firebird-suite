// Code generated by Firebird. DO NOT EDIT.

package events

import (
	"context"
	"fmt"
	"log/slog"
	"sync"
	"time"
)

// MemoryBus is an in-memory event bus (single instance only)
type MemoryBus struct {
	mu          sync.RWMutex
	subscribers map[string][]chan Event
	logger      *slog.Logger
	closed      bool
	bufferSize  int
}

// NewMemoryBus creates a new in-memory event bus
func NewMemoryBus(logger *slog.Logger) *MemoryBus {
	return &MemoryBus{
		subscribers: make(map[string][]chan Event),
		logger:      logger,
		bufferSize:  100, // Buffer 100 events per subscriber
	}
}

// Publish sends an event to all matching subscribers
func (mb *MemoryBus) Publish(ctx context.Context, topic string, data interface{}) error {
	mb.mu.RLock()
	defer mb.mu.RUnlock()

	if mb.closed {
		return fmt.Errorf("event bus is closed")
	}

	event := Event{
		Topic:     topic,
		Data:      data,
		Timestamp: time.Now(),
	}

	// Find matching subscribers
	var sent int
	for pattern, channels := range mb.subscribers {
		if !MatchTopic(pattern, topic) {
			continue
		}

		for _, ch := range channels {
			select {
			case ch <- event:
				sent++
			default:
				// Channel full, log warning
				mb.logger.WarnContext(ctx, "event channel full, dropping event",
					slog.String("topic", topic),
					slog.String("pattern", pattern),
				)
			}
		}
	}

	mb.logger.DebugContext(ctx, "event published",
		slog.String("topic", topic),
		slog.Int("subscribers", sent),
	)

	return nil
}

// Subscribe creates a subscription to a topic pattern
func (mb *MemoryBus) Subscribe(ctx context.Context, pattern string) (<-chan Event, error) {
	mb.mu.Lock()
	defer mb.mu.Unlock()

	if mb.closed {
		return nil, fmt.Errorf("event bus is closed")
	}

	ch := make(chan Event, mb.bufferSize)
	mb.subscribers[pattern] = append(mb.subscribers[pattern], ch)

	mb.logger.InfoContext(ctx, "subscription created",
		slog.String("pattern", pattern),
	)

	return ch, nil
}

// Unsubscribe removes all subscriptions for a pattern
func (mb *MemoryBus) Unsubscribe(pattern string) error {
	mb.mu.Lock()
	defer mb.mu.Unlock()

	channels, exists := mb.subscribers[pattern]
	if !exists {
		return nil
	}

	// Close all channels for this pattern
	for _, ch := range channels {
		close(ch)
	}

	delete(mb.subscribers, pattern)

	mb.logger.Info("subscription removed",
		slog.String("pattern", pattern),
	)

	return nil
}

// Close shuts down the event bus
func (mb *MemoryBus) Close() error {
	mb.mu.Lock()
	defer mb.mu.Unlock()

	if mb.closed {
		return nil
	}

	mb.closed = true

	// Close all subscriber channels
	for pattern, channels := range mb.subscribers {
		for _, ch := range channels {
			close(ch)
		}
		delete(mb.subscribers, pattern)
	}

	mb.logger.Info("event bus closed")

	return nil
}
