// Code generated by Firebird. DO NOT EDIT.
package logging

import (
	"context"
	"fmt"
	"io"
	"log/slog"
	"os"
	"runtime"
	"strings"
	"time"

	"github.com/fatih/color"
)

// ConsoleHandler is a beautiful colored console handler for development
type ConsoleHandler struct {
	opts   HandlerOptions
	writer io.Writer
	attrs  []slog.Attr
	groups []string

	// Color functions
	levelColors map[slog.Level]*color.Color
	keyColor    *color.Color
	valueColor  *color.Color
	timeColor   *color.Color
	sourceColor *color.Color
}

// HandlerOptions configures the console handler
type HandlerOptions struct {
	Level     slog.Leveler
	AddSource bool
	NoColor   bool
}

// NewConsoleHandler creates a new beautiful console handler
func NewConsoleHandler(w io.Writer, opts *HandlerOptions) *ConsoleHandler {
	if opts == nil {
		opts = &HandlerOptions{Level: slog.LevelInfo}
	}

	// Detect if output is a TTY
	noColor := opts.NoColor
	if !noColor {
		if f, ok := w.(*os.File); ok {
			if !isTerminal(f) {
				noColor = true
			}
		}
	}

	// Check NO_COLOR environment variable
	if os.Getenv("NO_COLOR") != "" {
		noColor = true
	}

	h := &ConsoleHandler{
		opts:   *opts,
		writer: w,
		attrs:  []slog.Attr{},
		groups: []string{},
	}

	// Set up colors (disabled if noColor)
	if noColor {
		color.NoColor = true
	}

	h.levelColors = map[slog.Level]*color.Color{
		slog.LevelDebug: color.New(color.FgCyan),
		slog.LevelInfo:  color.New(color.FgGreen),
		slog.LevelWarn:  color.New(color.FgYellow),
		slog.LevelError: color.New(color.FgRed),
	}
	h.keyColor = color.New(color.FgCyan)
	h.valueColor = color.New(color.FgWhite)
	h.timeColor = color.New(color.FgHiBlack)
	h.sourceColor = color.New(color.FgHiBlack)

	return h
}

// Enabled returns whether the handler is enabled for the given level
func (h *ConsoleHandler) Enabled(ctx context.Context, level slog.Level) bool {
	minLevel := slog.LevelInfo
	if h.opts.Level != nil {
		minLevel = h.opts.Level.Level()
	}
	return level >= minLevel
}

// Handle processes a log record
func (h *ConsoleHandler) Handle(ctx context.Context, r slog.Record) error {
	var buf strings.Builder

	// Emoji prefix based on level
	switch r.Level {
	case slog.LevelDebug:
		buf.WriteString("🔍 ")
	case slog.LevelInfo:
		buf.WriteString("✨ ")
	case slog.LevelWarn:
		buf.WriteString("⚠️  ")
	case slog.LevelError:
		buf.WriteString("❌ ")
	}

	// Level (colored)
	levelColor := h.levelColors[r.Level]
	if levelColor == nil {
		levelColor = h.valueColor
	}
	buf.WriteString(levelColor.Sprintf("[%-5s]", r.Level.String()))
	buf.WriteString(" ")

	// Time (gray)
	timeStr := r.Time.Format("15:04:05")
	buf.WriteString(h.timeColor.Sprint(timeStr))
	buf.WriteString(" | ")

	// Message
	buf.WriteString(h.valueColor.Sprint(r.Message))

	// Attributes
	attrs := make([]slog.Attr, 0, len(h.attrs)+r.NumAttrs())
	attrs = append(attrs, h.attrs...)
	r.Attrs(func(a slog.Attr) bool {
		attrs = append(attrs, a)
		return true
	})

	if len(attrs) > 0 {
		buf.WriteString(" | ")
		h.formatAttrs(&buf, attrs)
	}

	// Source (if enabled)
	if h.opts.AddSource && r.PC != 0 {
		fs := runtime.CallersFrames([]uintptr{r.PC})
		f, _ := fs.Next()
		buf.WriteString(" ")
		buf.WriteString(h.sourceColor.Sprintf("(%s:%d)", f.File, f.Line))
	}

	buf.WriteString("\n")

	_, err := h.writer.Write([]byte(buf.String()))
	return err
}

// formatAttrs formats attributes with colors
func (h *ConsoleHandler) formatAttrs(buf *strings.Builder, attrs []slog.Attr) {
	for i, attr := range attrs {
		if i > 0 {
			buf.WriteString(" ")
		}

		key := attr.Key
		value := attr.Value

		// Special formatting for known keys
		switch key {
		case "request_id":
			buf.WriteString(color.New(color.FgMagenta).Sprintf("%s=%s", key, value.String()))
		case "duration_ms", "duration":
			buf.WriteString(color.New(color.FgYellow).Sprintf("%s=%v", key, value.Any()))
		case "status":
			status := value.Any()
			var statusColor *color.Color
			if s, ok := status.(int); ok {
				switch {
				case s >= 500:
					statusColor = color.New(color.FgRed, color.Bold)
				case s >= 400:
					statusColor = color.New(color.FgYellow)
				case s >= 300:
					statusColor = color.New(color.FgCyan)
				case s >= 200:
					statusColor = color.New(color.FgGreen)
				default:
					statusColor = h.valueColor
				}
				buf.WriteString(fmt.Sprintf("%s=%s", h.keyColor.Sprint(key), statusColor.Sprint(status)))
			} else {
				buf.WriteString(fmt.Sprintf("%s=%v", h.keyColor.Sprint(key), value.Any()))
			}
		case "error":
			buf.WriteString(fmt.Sprintf("%s=%s",
				color.New(color.FgRed).Sprint(key),
				color.New(color.FgRed).Sprint(value.String())))
		case "layer":
			layerColor := color.New(color.FgBlue)
			buf.WriteString(fmt.Sprintf("%s=%s", h.keyColor.Sprint(key), layerColor.Sprint(value.String())))
		default:
			buf.WriteString(fmt.Sprintf("%s=%v", h.keyColor.Sprint(key), h.formatValue(value)))
		}
	}
}

// formatValue formats a value with appropriate color
func (h *ConsoleHandler) formatValue(v slog.Value) string {
	switch v.Kind() {
	case slog.KindString:
		return h.valueColor.Sprintf("%q", v.String())
	case slog.KindInt64, slog.KindUint64, slog.KindFloat64:
		return color.New(color.FgCyan).Sprint(v.Any())
	case slog.KindBool:
		if v.Bool() {
			return color.New(color.FgGreen).Sprint("true")
		}
		return color.New(color.FgRed).Sprint("false")
	case slog.KindDuration:
		return color.New(color.FgYellow).Sprint(v.Duration())
	case slog.KindTime:
		return h.timeColor.Sprint(v.Time().Format(time.RFC3339))
	default:
		return fmt.Sprintf("%v", v.Any())
	}
}

// WithAttrs creates a new handler with additional attributes
func (h *ConsoleHandler) WithAttrs(attrs []slog.Attr) slog.Handler {
	newAttrs := make([]slog.Attr, len(h.attrs)+len(attrs))
	copy(newAttrs, h.attrs)
	copy(newAttrs[len(h.attrs):], attrs)

	return &ConsoleHandler{
		opts:        h.opts,
		writer:      h.writer,
		attrs:       newAttrs,
		groups:      h.groups,
		levelColors: h.levelColors,
		keyColor:    h.keyColor,
		valueColor:  h.valueColor,
		timeColor:   h.timeColor,
		sourceColor: h.sourceColor,
	}
}

// WithGroup creates a new handler with a group name
func (h *ConsoleHandler) WithGroup(name string) slog.Handler {
	if name == "" {
		return h
	}

	newGroups := make([]string, len(h.groups)+1)
	copy(newGroups, h.groups)
	newGroups[len(h.groups)] = name

	return &ConsoleHandler{
		opts:        h.opts,
		writer:      h.writer,
		attrs:       h.attrs,
		groups:      newGroups,
		levelColors: h.levelColors,
		keyColor:    h.keyColor,
		valueColor:  h.valueColor,
		timeColor:   h.timeColor,
		sourceColor: h.sourceColor,
	}
}

// isTerminal checks if the file descriptor is a terminal
func isTerminal(f *os.File) bool {
	// Simple check - a real implementation would use syscalls
	// For now, assume stdout/stderr are terminals
	return f == os.Stdout || f == os.Stderr
}
