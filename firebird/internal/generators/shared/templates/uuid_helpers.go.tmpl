// Code generated by Firebird. DO NOT EDIT.

package helpers

import (
	"net/http"

	"github.com/google/uuid"
	apperrors "{{ .ModulePath }}/internal/errors"
)

// ParseUUID parses a string into a UUID, returning error if invalid
func ParseUUID(s string) (uuid.UUID, error) {
	id, err := uuid.Parse(s)
	if err != nil {
		return uuid.Nil, apperrors.NewBadRequestError("Invalid UUID format")
	}
	return id, nil
}

// MustParseUUID parses a string into a UUID, panicking if invalid
// Only use in tests or when you're certain the input is valid
func MustParseUUID(s string) uuid.UUID {
	id, err := uuid.Parse(s)
	if err != nil {
		panic("invalid UUID: " + s)
	}
	return id
}

// GetPathUUID extracts and parses a UUID from the URL path
// Works with chi, stdlib, and other routers that use URL parameters
func GetPathUUID(r *http.Request, paramName string) (uuid.UUID, error) {
	// Try chi-style URL params first
	if param := r.PathValue(paramName); param != "" {
		return ParseUUID(param)
	}

	// Fallback to query param
	if param := r.URL.Query().Get(paramName); param != "" {
		return ParseUUID(param)
	}

	return uuid.Nil, apperrors.NewBadRequestError("Missing or invalid UUID parameter")
}

// IsValidUUID checks if a string is a valid UUID
func IsValidUUID(s string) bool {
	_, err := uuid.Parse(s)
	return err == nil
}

// UUIDSliceToStrings converts []uuid.UUID to []string
func UUIDSliceToStrings(uuids []uuid.UUID) []string {
	strings := make([]string, len(uuids))
	for i, id := range uuids {
		strings[i] = id.String()
	}
	return strings
}

// StringsToUUIDSlice converts []string to []uuid.UUID
// Returns error if any string is not a valid UUID
func StringsToUUIDSlice(strings []string) ([]uuid.UUID, error) {
	uuids := make([]uuid.UUID, len(strings))
	for i, s := range strings {
		id, err := uuid.Parse(s)
		if err != nil {
			return nil, apperrors.NewBadRequestError("Invalid UUID in list: " + s)
		}
		uuids[i] = id
	}
	return uuids, nil
}
