// Code generated by Firebird. DO NOT EDIT.

package events

import (
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"sync"
	"time"

	"github.com/nats-io/nats.go"
)

// NATSBus is a NATS-backed event bus (multi-instance support)
type NATSBus struct {
	conn          *nats.Conn
	logger        *slog.Logger
	mu            sync.RWMutex
	subscriptions map[string]*nats.Subscription
	closed        bool
}

// NewNATSBus creates a new NATS event bus
func NewNATSBus(url string, logger *slog.Logger) (*NATSBus, error) {
	conn, err := nats.Connect(url)
	if err != nil {
		return nil, fmt.Errorf("failed to connect to NATS: %w", err)
	}

	nb := &NATSBus{
		conn:          conn,
		logger:        logger,
		subscriptions: make(map[string]*nats.Subscription),
	}

	logger.Info("NATS event bus connected", slog.String("url", url))

	return nb, nil
}

// Publish sends an event to NATS
func (nb *NATSBus) Publish(ctx context.Context, topic string, data interface{}) error {
	nb.mu.RLock()
	defer nb.mu.RUnlock()

	if nb.closed {
		return fmt.Errorf("event bus is closed")
	}

	event := Event{
		Topic:     topic,
		Data:      data,
		Timestamp: time.Now(),
	}

	// Marshal event to JSON
	payload, err := json.Marshal(event)
	if err != nil {
		return fmt.Errorf("failed to marshal event: %w", err)
	}

	// Publish to NATS
	// Convert dots to NATS subject format (same syntax!)
	if err := nb.conn.Publish(topic, payload); err != nil {
		return fmt.Errorf("failed to publish to NATS: %w", err)
	}

	nb.logger.DebugContext(ctx, "event published to NATS",
		slog.String("topic", topic),
	)

	return nil
}

// Subscribe creates a NATS subscription
func (nb *NATSBus) Subscribe(ctx context.Context, pattern string) (<-chan Event, error) {
	nb.mu.Lock()
	defer nb.mu.Unlock()

	if nb.closed {
		return nil, fmt.Errorf("event bus is closed")
	}

	// Check if already subscribed
	if _, exists := nb.subscriptions[pattern]; exists {
		return nil, fmt.Errorf("already subscribed to pattern: %s", pattern)
	}

	ch := make(chan Event, 100)

	// NATS subscription with callback
	sub, err := nb.conn.Subscribe(pattern, func(msg *nats.Msg) {
		var event Event
		if err := json.Unmarshal(msg.Data, &event); err != nil {
			nb.logger.Error("failed to unmarshal NATS message",
				slog.String("error", err.Error()),
			)
			return
		}

		// Send to channel (non-blocking)
		select {
		case ch <- event:
		default:
			nb.logger.Warn("event channel full, dropping event",
				slog.String("pattern", pattern),
			)
		}
	})

	if err != nil {
		close(ch)
		return nil, fmt.Errorf("failed to subscribe to NATS: %w", err)
	}

	nb.subscriptions[pattern] = sub

	nb.logger.InfoContext(ctx, "NATS subscription created",
		slog.String("pattern", pattern),
	)

	return ch, nil
}

// Unsubscribe removes a NATS subscription
func (nb *NATSBus) Unsubscribe(pattern string) error {
	nb.mu.Lock()
	defer nb.mu.Unlock()

	sub, exists := nb.subscriptions[pattern]
	if !exists {
		return nil
	}

	if err := sub.Unsubscribe(); err != nil {
		return fmt.Errorf("failed to unsubscribe from NATS: %w", err)
	}

	delete(nb.subscriptions, pattern)

	nb.logger.Info("NATS subscription removed",
		slog.String("pattern", pattern),
	)

	return nil
}

// Close shuts down the NATS connection
func (nb *NATSBus) Close() error {
	nb.mu.Lock()
	defer nb.mu.Unlock()

	if nb.closed {
		return nil
	}

	nb.closed = true

	// Unsubscribe from all
	for pattern, sub := range nb.subscriptions {
		sub.Unsubscribe()
		delete(nb.subscriptions, pattern)
	}

	// Close NATS connection
	nb.conn.Close()

	nb.logger.Info("NATS event bus closed")

	return nil
}
