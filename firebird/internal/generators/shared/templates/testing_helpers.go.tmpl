// Code generated by Firebird. DO NOT EDIT.
// Testing utilities for integration tests.

package testhelpers

import (
	"context"
	"database/sql"
	"fmt"
	"testing"

	"github.com/google/uuid"
	_ "github.com/mattn/go-sqlite3"
)

// NewTestDB creates an in-memory SQLite database for testing
func NewTestDB(t *testing.T) *sql.DB {
	t.Helper()

	db, err := sql.Open("sqlite3", ":memory:")
	if err != nil {
		t.Fatalf("failed to open test database: %v", err)
	}

	t.Cleanup(func() {
		db.Close()
	})

	return db
}

// NewTestContext creates a context for testing
func NewTestContext() context.Context {
	return context.Background()
}

// NewTestContextWithUser creates a context with a user ID for testing auth
func NewTestContextWithUser(userID uuid.UUID) context.Context {
	// NOTE: Update this when you add your auth system
	ctx := context.Background()
	return context.WithValue(ctx, "user_id", userID)
}

// AssertNoError fails the test if err is not nil
func AssertNoError(t *testing.T, err error) {
	t.Helper()
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
}

// AssertError fails the test if err is nil
func AssertError(t *testing.T, err error) {
	t.Helper()
	if err == nil {
		t.Fatal("expected error but got nil")
	}
}

// AssertEqual fails the test if expected != actual
func AssertEqual(t *testing.T, expected, actual interface{}) {
	t.Helper()
	if expected != actual {
		t.Fatalf("expected %v but got %v", expected, actual)
	}
}

// AssertNotEqual fails the test if expected == actual
func AssertNotEqual(t *testing.T, expected, actual interface{}) {
	t.Helper()
	if expected == actual {
		t.Fatalf("expected %v to not equal %v", expected, actual)
	}
}

// TruncateTables removes all data from tables (for test cleanup)
// Note: Only works with SQLite in-memory DB
func TruncateTables(t *testing.T, db *sql.DB, tables ...string) {
	t.Helper()

	for _, table := range tables {
		_, err := db.Exec(fmt.Sprintf("DELETE FROM %s", table))
		if err != nil {
			t.Fatalf("failed to truncate table %s: %v", table, err)
		}
	}
}

// RunInTransaction executes a function within a transaction
// Rolls back on error or panic
func RunInTransaction(t *testing.T, db *sql.DB, fn func(*sql.Tx) error) error {
	t.Helper()

	tx, err := db.Begin()
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}

	defer func() {
		if p := recover(); p != nil {
			tx.Rollback()
			panic(p)
		}
	}()

	if err := fn(tx); err != nil {
		tx.Rollback()
		return err
	}

	return tx.Commit()
}
