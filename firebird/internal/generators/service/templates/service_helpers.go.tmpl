// Code generated by Firebird. DO NOT EDIT.
// This file is regenerated when the schema changes.

package generated

import (
	"context"
	"fmt"
	"strings"

	"{{ .ModulePath }}/internal/db"
	"{{ .ModulePath }}/internal/dto"
	"{{ .ModulePath }}/internal/repositories"
)

// {{ .ModelName }}ServiceHelpers provides relationship loading utilities.
// These methods help avoid N+1 query problems when loading related data.
type {{ .ModelName }}ServiceHelpers struct {
	service *{{ .ModelName }}ServiceImpl
}

// Helpers returns the relationship loading helpers for this service.
func (s *{{ .ModelName }}ServiceImpl) Helpers() *{{ .ModelName }}ServiceHelpers {
	return &{{ .ModelName }}ServiceHelpers{service: s}
}
{{- range .Relationships }}

{{- if .IsSingle }}
// {{ .LoadMethod }} loads the related {{ .Model }} for a {{ $.ModelName }}.
//
// Example usage:
//   {{ $.ModelNameLower }}, _ := service.GetByID(ctx, id)
//   {{ .Name | lower }}, err := service.Helpers().{{ .LoadMethod }}(ctx, {{ $.ModelNameLower }})
func (h *{{ $.ModelName }}ServiceHelpers) {{ .LoadMethod }}(ctx context.Context, entity *dto.{{ $.ModelName }}Response) (*dto.{{ .Model }}Response, error) {
	// Convert DTO back to DB model (only need ID for loading)
	dbModel := &db.{{ $.ModelName }}{
		ID: entity.ID,
	}

	related, err := h.service.{{ $.RepoFieldName }}.{{ .LoadMethod }}(ctx, dbModel)
	if err != nil {
		return nil, fmt.Errorf("load {{ .Name }}: %w", err)
	}

	if related == nil {
		return nil, nil
	}

	return dto.From{{ .Model }}(related), nil
}
{{- end }}

{{- if .IsMany }}
// {{ .LoadMethod }} loads all related {{ .Model }}s for a {{ $.ModelName }}.
//
// Example usage:
//   {{ $.ModelNameLower }}, _ := service.GetByID(ctx, id)
//   {{ .Name | lower }}, err := service.Helpers().{{ .LoadMethod }}(ctx, {{ $.ModelNameLower }})
func (h *{{ $.ModelName }}ServiceHelpers) {{ .LoadMethod }}(ctx context.Context, entity *dto.{{ $.ModelName }}Response) ([]dto.{{ .Model }}Response, error) {
	// Convert DTO back to DB model (only need ID for loading)
	dbModel := &db.{{ $.ModelName }}{
		ID: entity.ID,
	}

	related, err := h.service.{{ $.RepoFieldName }}.{{ .LoadMethod }}(ctx, dbModel)
	if err != nil {
		return nil, fmt.Errorf("load {{ .Name }}: %w", err)
	}

	return dto.From{{ .Model }}List(related), nil
}

// {{ .LoadManyMethod }} batch loads {{ .Model }}s for multiple {{ $.ModelName }}s.
// This prevents N+1 queries when loading relationships for a list.
//
// Example usage:
//   {{ $.ModelNameLower }}s, _ := service.List(ctx, page)
//   {{ .Name | lower }}Map, err := service.Helpers().{{ .LoadManyMethod }}(ctx, {{ $.ModelNameLower }}s.Items)
//   // {{ .Name | lower }}Map[{{ $.ModelNameLower }}ID] gives you the {{ .Model }}s for that {{ $.ModelName }}
func (h *{{ $.ModelName }}ServiceHelpers) {{ .LoadManyMethod }}(ctx context.Context, entities []*dto.{{ $.ModelName }}Response) (map[interface{}][]dto.{{ .Model }}Response, error) {
	if len(entities) == 0 {
		return make(map[interface{}][]dto.{{ .Model }}Response), nil
	}

	// Convert DTOs back to DB models (only need IDs for loading)
	dbModels := make([]db.{{ $.ModelName }}, len(entities))
	for i, entity := range entities {
		dbModels[i] = db.{{ $.ModelName }}{
			ID: entity.ID,
		}
	}

	relatedMap, err := h.service.{{ $.RepoFieldName }}.{{ .LoadManyMethod }}(ctx, dbModels)
	if err != nil {
		return nil, fmt.Errorf("batch load {{ .Name }}: %w", err)
	}

	// Convert DB models to DTOs
	result := make(map[interface{}][]dto.{{ .Model }}Response)
	for id, dbRelated := range relatedMap {
		result[id] = dto.From{{ .Model }}List(dbRelated)
	}

	return result, nil
}
{{- end }}
{{- end }}
{{- if .HasAPILoadableRelationships }}

// Load{{ .ModelName }}Relationships loads related data based on the includes slice.
// Validates includes against schema whitelist before loading.
// Only relationships with api_loadable: true can be loaded via API.
func Load{{ .ModelName }}Relationships(ctx context.Context, entity *dto.{{ .ModelName }}Response, includes []string, repo repositories.{{ .ModelName }}Repository) error {
	if len(includes) == 0 {
		return nil
	}

	// Validate includes against schema whitelist (only api_loadable: true relationships)
	if err := repo.ValidateIncludes(includes); err != nil {
		return err
	}

	// Convert DTO to DB model for loading
	dbModel := &db.{{ .ModelName }}{
		ID: entity.ID,
	}

	for _, include := range includes {
		switch strings.ToLower(include) {
		{{- range .Relationships }}
		{{- if .APILoadable }}
		case "{{ .Name | lower }}":
			{{- if .IsSingle }}
			related, err := repo.Load{{ .Name }}(ctx, dbModel)
			if err != nil {
				return fmt.Errorf("loading {{ .Name }}: %w", err)
			}
			if related != nil {
				entity.{{ .Name }} = dto.From{{ .Model }}(related)
			}
			{{- else }}
			related, err := repo.Load{{ .Name }}(ctx, dbModel)
			if err != nil {
				return fmt.Errorf("loading {{ .Name }}: %w", err)
			}
			entity.{{ .Name }} = dto.From{{ .Model }}List(related)
			{{- end }}
		{{- end }}
		{{- end }}
		default:
			// This shouldn't happen if ValidateIncludes passed, but be defensive
			return fmt.Errorf("unknown relationship: %s", include)
		}
	}
	return nil
}
{{- end }}
