package repositories

import (
	"log/slog"

	"{{ .ModulePath }}/internal/db"
)

// {{ .ModelName }}Repository handles {{ .ModelName }} data access.
//
// Generated methods (via {{ .ModelName }}RepositoryBase):
//   - Create(ctx, params) (*db.{{ .ModelName }}, error)
//   - GetByID(ctx, id) (*db.{{ .ModelName }}, error)
//   - List(ctx) ([]db.{{ .ModelName }}, error)
//   - ListPaginated(ctx, limit, offset) ([]db.{{ .ModelName }}, error)
//   - Count(ctx) (int64, error)
//   - Update(ctx, params) (*db.{{ .ModelName }}, error)
//   - Delete(ctx, id) error
{{- if .SoftDeletes }}
//   - Restore(ctx, id) error
{{- end }}
//   - WithTx(ctx, fn) error
{{- if .Relationships }}
//
// Relationship loading:
{{- range .Relationships }}
{{- if .IsSingle }}
//   - {{ .LoadMethod }}(ctx, entity) (*db.{{ .Model }}, error)
{{- end }}
{{- if .IsMany }}
//   - {{ .LoadMethod }}(ctx, entity) ([]db.{{ .Model }}, error)
//   - {{ .LoadManyMethod }}(ctx, entities) (map[ID][]db.{{ .Model }}, error)
{{- end }}
{{- end }}
{{- end }}
//
// Add custom queries and business logic below.
type {{ .ModelName }}Repository struct {
	{{ .ModelName }}RepositoryBase
}

// New{{ .ModelName }}Repository creates a new {{ .ModelName }} repository.
func New{{ .ModelName }}Repository(database *db.DB, logger *slog.Logger) *{{ .ModelName }}Repository {
	return &{{ .ModelName }}Repository{
		{{ .ModelName }}RepositoryBase: {{ .ModelName }}RepositoryBase{
			queries: database.Queries(),
			db:      database,
			logger:  logger.With(slog.String("repository", "{{ .ModelName }}")),
		},
	}
}

// Add custom methods here:
