// Code generated by Firebird. DO NOT EDIT.
// This file is regenerated when the schema changes.

package repositories

import (
	"context"
	"fmt"

	"{{ .ModulePath }}/internal/db"
)

// {{ .ModelName }}RepositoryBase provides generated CRUD operations.
// Embed this in your {{ .ModelName }}Repository to inherit these methods.
type {{ .ModelName }}RepositoryBase struct {
	queries *db.Queries
	db      *db.DB
}

// Create creates a new {{ .ModelName }}.
func (r *{{ .ModelName }}RepositoryBase) Create(ctx context.Context, params db.Create{{ .ModelName }}Params) (*db.{{ .ModelName }}, error) {
	return r.queries.Create{{ .ModelName }}(ctx, params)
}

// GetByID retrieves a {{ .ModelName }} by ID.
func (r *{{ .ModelName }}RepositoryBase) GetByID(ctx context.Context, id {{ .PrimaryKeyType }}) (*db.{{ .ModelName }}, error) {
	return r.queries.Get{{ .ModelName }}(ctx, id)
}

// List retrieves all {{ .ModelName }}s.
func (r *{{ .ModelName }}RepositoryBase) List(ctx context.Context) ([]db.{{ .ModelName }}, error) {
	return r.queries.List{{ .ModelName }}s(ctx)
}

// ListPaginated retrieves {{ .ModelName }}s with pagination.
func (r *{{ .ModelName }}RepositoryBase) ListPaginated(ctx context.Context, limit, offset int32) ([]db.{{ .ModelName }}, error) {
	return r.queries.List{{ .ModelName }}sPaginated(ctx, db.List{{ .ModelName }}sPaginatedParams{
		Limit:  limit,
		Offset: offset,
	})
}

// Count returns the total number of {{ .ModelName }}s.
func (r *{{ .ModelName }}RepositoryBase) Count(ctx context.Context) (int64, error) {
	return r.queries.Count{{ .ModelName }}s(ctx)
}

// Update updates a {{ .ModelName }}.
func (r *{{ .ModelName }}RepositoryBase) Update(ctx context.Context, params db.Update{{ .ModelName }}Params) (*db.{{ .ModelName }}, error) {
	return r.queries.Update{{ .ModelName }}(ctx, params)
}

// Delete deletes a {{ .ModelName }}.
{{- if .SoftDeletes }}
// Note: This performs a soft delete (sets deleted_at timestamp).
{{- end }}
func (r *{{ .ModelName }}RepositoryBase) Delete(ctx context.Context, id {{ .PrimaryKeyType }}) error {
	return r.queries.Delete{{ .ModelName }}(ctx, id)
}
{{- if .SoftDeletes }}

// Restore restores a soft-deleted {{ .ModelName }}.
func (r *{{ .ModelName }}RepositoryBase) Restore(ctx context.Context, id {{ .PrimaryKeyType }}) error {
	return r.queries.Restore{{ .ModelName }}(ctx, id)
}
{{- end }}

// WithTx executes a function within a database transaction.
// If the function returns an error, the transaction is rolled back.
// If the function panics, the transaction is rolled back and the panic is re-raised.
// Otherwise, the transaction is committed.
//
// Example:
//   err := repo.WithTx(ctx, func(txRepo {{ .ModelName }}Repository) error {
//       _, err := txRepo.Create(ctx, createParams)
//       if err != nil {
//           return err
//       }
//       // More operations...
//       return nil
//   })
func (r *{{ .ModelName }}RepositoryBase) WithTx(ctx context.Context, fn func({{ .ModelName }}Repository) error) error {
	// Begin transaction
	tx, err := r.db.Begin(ctx)
	if err != nil {
		return fmt.Errorf("begin transaction: %w", err)
	}

	// Create new queries instance bound to transaction
	txQueries := r.queries.WithTx(tx)

	// Create new repository instance with transaction-bound queries
	txRepo := &{{ .ModelName }}Repository{
		{{ .ModelName }}RepositoryBase: {{ .ModelName }}RepositoryBase{
			queries: txQueries,
			db:      r.db,
		},
	}

	// Handle panic and errors with proper cleanup
	var fnErr error
	defer func() {
		if p := recover(); p != nil {
			// Rollback on panic
			_ = tx.Rollback()
			panic(p) // Re-raise panic
		} else if fnErr != nil {
			// Rollback on error
			_ = tx.Rollback()
		} else {
			// Commit on success
			fnErr = tx.Commit()
			if fnErr != nil {
				fnErr = fmt.Errorf("commit transaction: %w", fnErr)
			}
		}
	}()

	// Execute function
	fnErr = fn(txRepo)
	return fnErr
}
