// Code generated by Firebird. DO NOT EDIT.

package realtime

import (
	"context"
	"fmt"
	"log/slog"
	"sync"
	"time"

	"{{ .ModulePath }}/internal/events"
)

// PresenceInfo represents a user's presence data
type PresenceInfo struct {
	UserID       string                 `json:"user_id"`
	ConnectionID string                 `json:"connection_id"`
	Metadata     map[string]interface{} `json:"metadata"`
	JoinedAt     time.Time              `json:"joined_at"`
	LastSeenAt   time.Time              `json:"last_seen_at"`
}

// PresenceManager tracks online users
type PresenceManager struct {
	// topic -> userID -> []PresenceInfo (user can have multiple connections)
	presence map[string]map[string][]*PresenceInfo
	mu       sync.RWMutex
	eventBus events.EventBus
	logger   *slog.Logger
}

// NewPresenceManager creates a presence manager
func NewPresenceManager(eventBus events.EventBus, logger *slog.Logger) *PresenceManager {
	return &PresenceManager{
		presence: make(map[string]map[string][]*PresenceInfo),
		eventBus: eventBus,
		logger:   logger,
	}
}

// Track adds a user's presence to a topic
func (pm *PresenceManager) Track(ctx context.Context, topic, userID, connectionID string, metadata map[string]interface{}) error {
	pm.mu.Lock()
	defer pm.mu.Unlock()

	if pm.presence[topic] == nil {
		pm.presence[topic] = make(map[string][]*PresenceInfo)
	}

	info := &PresenceInfo{
		UserID:       userID,
		ConnectionID: connectionID,
		Metadata:     metadata,
		JoinedAt:     time.Now(),
		LastSeenAt:   time.Now(),
	}

	pm.presence[topic][userID] = append(pm.presence[topic][userID], info)

	// Broadcast presence_join event
	if err := pm.eventBus.Publish(ctx, topic+".presence_join", map[string]interface{}{
		"user_id":  userID,
		"metadata": metadata,
	}); err != nil {
		pm.logger.ErrorContext(ctx, "failed to broadcast presence_join",
			slog.String("error", err.Error()),
		)
	}

	pm.logger.InfoContext(ctx, "presence tracked",
		slog.String("topic", topic),
		slog.String("user_id", userID),
		slog.String("connection_id", connectionID),
	)

	return nil
}

// Untrack removes a user's presence from a topic
func (pm *PresenceManager) Untrack(ctx context.Context, topic, connectionID string) error {
	pm.mu.Lock()
	defer pm.mu.Unlock()

	userPresences, exists := pm.presence[topic]
	if !exists {
		return nil
	}

	var removedUserID string
	for userID, presences := range userPresences {
		for i, p := range presences {
			if p.ConnectionID == connectionID {
				// Remove this presence
				pm.presence[topic][userID] = append(presences[:i], presences[i+1:]...)
				removedUserID = userID

				// If user has no more connections in this topic, remove user entry
				if len(pm.presence[topic][userID]) == 0 {
					delete(pm.presence[topic], userID)

					// Broadcast presence_leave event
					if err := pm.eventBus.Publish(ctx, topic+".presence_leave", map[string]interface{}{
						"user_id": userID,
					}); err != nil {
						pm.logger.ErrorContext(ctx, "failed to broadcast presence_leave",
							slog.String("error", err.Error()),
						)
					}
				}

				break
			}
		}
		if removedUserID != "" {
			break
		}
	}

	pm.logger.InfoContext(ctx, "presence untracked",
		slog.String("topic", topic),
		slog.String("connection_id", connectionID),
	)

	return nil
}

// List returns all users present in a topic
func (pm *PresenceManager) List(topic string) map[string][]*PresenceInfo {
	pm.mu.RLock()
	defer pm.mu.RUnlock()

	result := make(map[string][]*PresenceInfo)
	if userPresences, exists := pm.presence[topic]; exists {
		for userID, presences := range userPresences {
			result[userID] = presences
		}
	}

	return result
}

// IsPresent checks if a user is present in a topic
func (pm *PresenceManager) IsPresent(topic, userID string) bool {
	pm.mu.RLock()
	defer pm.mu.RUnlock()

	if userPresences, exists := pm.presence[topic]; exists {
		if presences, exists := userPresences[userID]; exists {
			return len(presences) > 0
		}
	}

	return false
}

// UpdateMetadata updates presence metadata for a connection
func (pm *PresenceManager) UpdateMetadata(ctx context.Context, topic, connectionID string, metadata map[string]interface{}) error {
	pm.mu.Lock()
	defer pm.mu.Unlock()

	userPresences, exists := pm.presence[topic]
	if !exists {
		return fmt.Errorf("topic not found")
	}

	for userID, presences := range userPresences {
		for _, p := range presences {
			if p.ConnectionID == connectionID {
				p.Metadata = metadata
				p.LastSeenAt = time.Now()

				// Broadcast presence_update event
				if err := pm.eventBus.Publish(ctx, topic+".presence_update", map[string]interface{}{
					"user_id":  userID,
					"metadata": metadata,
				}); err != nil {
					pm.logger.ErrorContext(ctx, "failed to broadcast presence_update",
						slog.String("error", err.Error()),
					)
				}

				return nil
			}
		}
	}

	return fmt.Errorf("connection not found")
}
