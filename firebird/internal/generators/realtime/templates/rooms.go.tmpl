// Code generated by Firebird. DO NOT EDIT.

package realtime

import (
	"context"
	"fmt"
	"log/slog"
	"sync"
)

// Room represents a group of connections
type Room struct {
	Name        string
	Connections map[string]*Connection
	Metadata    map[string]interface{}
	mu          sync.RWMutex
}

// RoomManager manages rooms/channels
type RoomManager struct {
	rooms  map[string]*Room
	mu     sync.RWMutex
	logger *slog.Logger
}

// NewRoomManager creates a room manager
func NewRoomManager(logger *slog.Logger) *RoomManager {
	return &RoomManager{
		rooms:  make(map[string]*Room),
		logger: logger,
	}
}

// CreateRoom creates a new room
func (rm *RoomManager) CreateRoom(name string, metadata map[string]interface{}) (*Room, error) {
	rm.mu.Lock()
	defer rm.mu.Unlock()

	if _, exists := rm.rooms[name]; exists {
		return nil, fmt.Errorf("room already exists: %s", name)
	}

	room := &Room{
		Name:        name,
		Connections: make(map[string]*Connection),
		Metadata:    metadata,
	}

	rm.rooms[name] = room

	rm.logger.Info("room created",
		slog.String("room", name),
	)

	return room, nil
}

// GetOrCreateRoom gets or creates a room
func (rm *RoomManager) GetOrCreateRoom(name string) *Room {
	rm.mu.Lock()
	defer rm.mu.Unlock()

	if room, exists := rm.rooms[name]; exists {
		return room
	}

	room := &Room{
		Name:        name,
		Connections: make(map[string]*Connection),
		Metadata:    make(map[string]interface{}),
	}

	rm.rooms[name] = room

	rm.logger.Info("room auto-created",
		slog.String("room", name),
	)

	return room
}

// GetRoom returns a room by name
func (rm *RoomManager) GetRoom(name string) (*Room, bool) {
	rm.mu.RLock()
	defer rm.mu.RUnlock()
	room, exists := rm.rooms[name]
	return room, exists
}

// DeleteRoom removes a room
func (rm *RoomManager) DeleteRoom(name string) error {
	rm.mu.Lock()
	defer rm.mu.Unlock()

	room, exists := rm.rooms[name]
	if !exists {
		return fmt.Errorf("room not found: %s", name)
	}

	// Remove all connections from room
	room.mu.Lock()
	for connID := range room.Connections {
		delete(room.Connections, connID)
	}
	room.mu.Unlock()

	delete(rm.rooms, name)

	rm.logger.Info("room deleted",
		slog.String("room", name),
	)

	return nil
}

// Join adds a connection to a room
func (rm *RoomManager) Join(roomName string, connection *Connection) error {
	room := rm.GetOrCreateRoom(roomName)

	room.mu.Lock()
	defer room.mu.Unlock()

	room.Connections[connection.ID] = connection

	rm.logger.Info("connection joined room",
		slog.String("room", roomName),
		slog.String("connection_id", connection.ID),
		slog.Int("room_size", len(room.Connections)),
	)

	return nil
}

// Leave removes a connection from a room
func (rm *RoomManager) Leave(roomName string, connectionID string) error {
	room, exists := rm.GetRoom(roomName)
	if !exists {
		return fmt.Errorf("room not found: %s", roomName)
	}

	room.mu.Lock()
	defer room.mu.Unlock()

	delete(room.Connections, connectionID)

	rm.logger.Info("connection left room",
		slog.String("room", roomName),
		slog.String("connection_id", connectionID),
		slog.Int("room_size", len(room.Connections)),
	)

	return nil
}

// Broadcast sends a message to all connections in a room
func (rm *RoomManager) Broadcast(ctx context.Context, roomName string, message []byte) error {
	room, exists := rm.GetRoom(roomName)
	if !exists {
		return fmt.Errorf("room not found: %s", roomName)
	}

	room.mu.RLock()
	defer room.mu.RUnlock()

	for _, conn := range room.Connections {
		select {
		case conn.Send <- message:
		default:
			rm.logger.Warn("failed to send to connection (channel full)",
				slog.String("connection_id", conn.ID),
			)
		}
	}

	return nil
}

// BroadcastExcept sends a message to all connections except one
func (rm *RoomManager) BroadcastExcept(ctx context.Context, roomName string, excludeConnectionID string, message []byte) error {
	room, exists := rm.GetRoom(roomName)
	if !exists {
		return fmt.Errorf("room not found: %s", roomName)
	}

	room.mu.RLock()
	defer room.mu.RUnlock()

	for connID, conn := range room.Connections {
		if connID == excludeConnectionID {
			continue
		}

		select {
		case conn.Send <- message:
		default:
			rm.logger.Warn("failed to send to connection (channel full)",
				slog.String("connection_id", conn.ID),
			)
		}
	}

	return nil
}

// ListRooms returns all room names
func (rm *RoomManager) ListRooms() []string {
	rm.mu.RLock()
	defer rm.mu.RUnlock()

	rooms := make([]string, 0, len(rm.rooms))
	for name := range rm.rooms {
		rooms = append(rooms, name)
	}

	return rooms
}

// RoomSize returns the number of connections in a room
func (rm *RoomManager) RoomSize(roomName string) int {
	room, exists := rm.GetRoom(roomName)
	if !exists {
		return 0
	}

	room.mu.RLock()
	defer room.mu.RUnlock()

	return len(room.Connections)
}
