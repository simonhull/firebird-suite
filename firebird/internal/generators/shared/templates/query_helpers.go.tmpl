// Code generated by Firebird. DO NOT EDIT.
// These are helper functions for common query patterns.

package helpers

import (
	"fmt"
	"net/url"
	"strconv"
	"strings"
)

// Pagination represents pagination parameters from query string
type Pagination struct {
	Page    int
	PerPage int
	Offset  int
}

// ParsePagination extracts pagination params from URL query
// Default: page=1, per_page=20, max=100
func ParsePagination(values url.Values) Pagination {
	page, _ := strconv.Atoi(values.Get("page"))
	if page < 1 {
		page = 1
	}

	perPage, _ := strconv.Atoi(values.Get("per_page"))
	if perPage < 1 {
		perPage = 20
	}
	if perPage > 100 {
		perPage = 100 // max limit
	}

	return Pagination{
		Page:    page,
		PerPage: perPage,
		Offset:  (page - 1) * perPage,
	}
}

// SortOrder represents a sort clause
type SortOrder struct {
	Field     string
	Direction string // "ASC" or "DESC"
}

// ParseSort parses sort parameter (e.g., "created_at:desc" or "-created_at")
// Returns empty slice if invalid
func ParseSort(sortParam string, allowedFields []string) []SortOrder {
	if sortParam == "" {
		return nil
	}

	var orders []SortOrder

	// Split by comma for multiple sorts
	parts := strings.Split(sortParam, ",")

	for _, part := range parts {
		part = strings.TrimSpace(part)
		if part == "" {
			continue
		}

		var field, direction string

		// Check for prefix notation (e.g., "-created_at")
		if strings.HasPrefix(part, "-") {
			field = part[1:]
			direction = "DESC"
		} else if strings.HasPrefix(part, "+") {
			field = part[1:]
			direction = "ASC"
		} else if strings.Contains(part, ":") {
			// Colon notation (e.g., "created_at:desc")
			splitPart := strings.Split(part, ":")
			field = splitPart[0]
			direction = strings.ToUpper(splitPart[1])
		} else {
			// No direction specified, default to ASC
			field = part
			direction = "ASC"
		}

		// Validate field is allowed
		if !contains(allowedFields, field) {
			continue
		}

		// Validate direction
		if direction != "ASC" && direction != "DESC" {
			direction = "ASC"
		}

		orders = append(orders, SortOrder{
			Field:     field,
			Direction: direction,
		})
	}

	return orders
}

// BuildOrderByClause converts sort orders to SQL ORDER BY clause
func BuildOrderByClause(orders []SortOrder) string {
	if len(orders) == 0 {
		return ""
	}

	var parts []string
	for _, order := range orders {
		parts = append(parts, fmt.Sprintf("%s %s", order.Field, order.Direction))
	}

	return "ORDER BY " + strings.Join(parts, ", ")
}

// Filter represents a single filter condition
type Filter struct {
	Field    string
	Operator string // "=", "!=", ">", "<", ">=", "<=", "LIKE", "IN"
	Value    interface{}
}

// ParseFilters extracts filter conditions from query params
// Example: ?status=published&min_age=18&tags=golang,web
func ParseFilters(values url.Values, allowedFilters map[string]string) []Filter {
	var filters []Filter

	for field, operator := range allowedFilters {
		value := values.Get(field)
		if value == "" {
			continue
		}

		// Handle IN operator (comma-separated)
		if operator == "IN" {
			values := strings.Split(value, ",")
			filters = append(filters, Filter{
				Field:    field,
				Operator: operator,
				Value:    values,
			})
			continue
		}

		filters = append(filters, Filter{
			Field:    field,
			Operator: operator,
			Value:    value,
		})
	}

	return filters
}

// SearchFilter represents a full-text search
type SearchFilter struct {
	Query  string
	Fields []string
}

// ParseSearch extracts search query from params
// Example: ?q=golang&search_fields=title,content
func ParseSearch(values url.Values, defaultFields []string) *SearchFilter {
	query := strings.TrimSpace(values.Get("q"))
	if query == "" {
		return nil
	}

	fields := defaultFields
	if searchFields := values.Get("search_fields"); searchFields != "" {
		fields = strings.Split(searchFields, ",")
	}

	return &SearchFilter{
		Query:  query,
		Fields: fields,
	}
}

// Helper functions

func contains(slice []string, item string) bool {
	for _, s := range slice {
		if s == item {
			return true
		}
	}
	return false
}
