// Code generated by Firebird. DO NOT EDIT.
// This file is regenerated when the schema changes.

package repositories

import (
	"context"
	"database/sql"
	"fmt"
	"log/slog"
	"time"

	"{{ .ModulePath }}/internal/db"
)

// {{ .ModelName }}RepositoryBase provides generated CRUD operations.
// Embed this in your {{ .ModelName }}Repository to inherit these methods.
type {{ .ModelName }}RepositoryBase struct {
	queries *db.Queries
	db      *db.DB
	logger  *slog.Logger
}

// Create creates a new {{ .ModelName }}.
func (r *{{ .ModelName }}RepositoryBase) Create(ctx context.Context, params db.Create{{ .ModelName }}Params) (*db.{{ .ModelName }}, error) {
	start := time.Now()

	result, err := r.queries.Create{{ .ModelName }}(ctx, params)

	duration := time.Since(start)

	if err != nil {
		r.logger.ErrorContext(ctx, "failed to create {{ .ModelName }}",
			slog.String("layer", "repository"),
			slog.String("operation", "Create"),
			slog.String("error", err.Error()),
			slog.Int64("duration_ms", duration.Milliseconds()),
		)
		return nil, err
	}

	if duration.Milliseconds() > 100 {
		r.logger.WarnContext(ctx, "slow query detected",
			slog.String("layer", "repository"),
			slog.String("operation", "Create"),
			slog.String("model", "{{ .ModelName }}"),
			slog.Int64("duration_ms", duration.Milliseconds()),
		)
	}

	return result, nil
}

// GetByID retrieves a {{ .ModelName }} by ID.
func (r *{{ .ModelName }}RepositoryBase) GetByID(ctx context.Context, id {{ .PrimaryKeyType }}) (*db.{{ .ModelName }}, error) {
	start := time.Now()

	result, err := r.queries.Get{{ .ModelName }}(ctx, id)

	duration := time.Since(start)

	if err != nil && err != sql.ErrNoRows {
		r.logger.ErrorContext(ctx, "failed to get {{ .ModelName }} by ID",
			slog.String("layer", "repository"),
			slog.String("operation", "GetByID"),
			slog.Any("id", id),
			slog.String("error", err.Error()),
			slog.Int64("duration_ms", duration.Milliseconds()),
		)
		return nil, err
	}

	if duration.Milliseconds() > 100 {
		r.logger.WarnContext(ctx, "slow query detected",
			slog.String("layer", "repository"),
			slog.String("operation", "GetByID"),
			slog.String("model", "{{ .ModelName }}"),
			slog.Any("id", id),
			slog.Int64("duration_ms", duration.Milliseconds()),
		)
	}

	return result, err
}

// List retrieves all {{ .ModelName }}s.
func (r *{{ .ModelName }}RepositoryBase) List(ctx context.Context) ([]db.{{ .ModelName }}, error) {
	start := time.Now()

	result, err := r.queries.List{{ .ModelName }}s(ctx)

	duration := time.Since(start)

	if err != nil {
		r.logger.ErrorContext(ctx, "failed to list {{ .ModelName }}s",
			slog.String("layer", "repository"),
			slog.String("operation", "List"),
			slog.String("error", err.Error()),
			slog.Int64("duration_ms", duration.Milliseconds()),
		)
		return nil, err
	}

	if duration.Milliseconds() > 100 {
		r.logger.WarnContext(ctx, "slow query detected",
			slog.String("layer", "repository"),
			slog.String("operation", "List"),
			slog.String("model", "{{ .ModelName }}"),
			slog.Int64("duration_ms", duration.Milliseconds()),
		)
	}

	return result, nil
}

// ListPaginated retrieves {{ .ModelName }}s with pagination.
func (r *{{ .ModelName }}RepositoryBase) ListPaginated(ctx context.Context, limit, offset int32) ([]db.{{ .ModelName }}, error) {
	start := time.Now()

	result, err := r.queries.List{{ .ModelName }}sPaginated(ctx, db.List{{ .ModelName }}sPaginatedParams{
		Limit:  limit,
		Offset: offset,
	})

	duration := time.Since(start)

	if err != nil {
		r.logger.ErrorContext(ctx, "failed to list {{ .ModelName }}s paginated",
			slog.String("layer", "repository"),
			slog.String("operation", "ListPaginated"),
			slog.Int("limit", int(limit)),
			slog.Int("offset", int(offset)),
			slog.String("error", err.Error()),
			slog.Int64("duration_ms", duration.Milliseconds()),
		)
		return nil, err
	}

	if duration.Milliseconds() > 100 {
		r.logger.WarnContext(ctx, "slow query detected",
			slog.String("layer", "repository"),
			slog.String("operation", "ListPaginated"),
			slog.String("model", "{{ .ModelName }}"),
			slog.Int64("duration_ms", duration.Milliseconds()),
		)
	}

	return result, nil
}

// Count returns the total number of {{ .ModelName }}s.
func (r *{{ .ModelName }}RepositoryBase) Count(ctx context.Context) (int64, error) {
	start := time.Now()

	result, err := r.queries.Count{{ .ModelName }}s(ctx)

	duration := time.Since(start)

	if err != nil {
		r.logger.ErrorContext(ctx, "failed to count {{ .ModelName }}s",
			slog.String("layer", "repository"),
			slog.String("operation", "Count"),
			slog.String("error", err.Error()),
			slog.Int64("duration_ms", duration.Milliseconds()),
		)
		return 0, err
	}

	if duration.Milliseconds() > 100 {
		r.logger.WarnContext(ctx, "slow query detected",
			slog.String("layer", "repository"),
			slog.String("operation", "Count"),
			slog.String("model", "{{ .ModelName }}"),
			slog.Int64("duration_ms", duration.Milliseconds()),
		)
	}

	return result, nil
}

// Update updates a {{ .ModelName }}.
func (r *{{ .ModelName }}RepositoryBase) Update(ctx context.Context, params db.Update{{ .ModelName }}Params) (*db.{{ .ModelName }}, error) {
	start := time.Now()

	result, err := r.queries.Update{{ .ModelName }}(ctx, params)

	duration := time.Since(start)

	if err != nil {
		r.logger.ErrorContext(ctx, "failed to update {{ .ModelName }}",
			slog.String("layer", "repository"),
			slog.String("operation", "Update"),
			slog.Any("id", params.ID),
			slog.String("error", err.Error()),
			slog.Int64("duration_ms", duration.Milliseconds()),
		)
		return nil, err
	}

	if duration.Milliseconds() > 100 {
		r.logger.WarnContext(ctx, "slow query detected",
			slog.String("layer", "repository"),
			slog.String("operation", "Update"),
			slog.String("model", "{{ .ModelName }}"),
			slog.Any("id", params.ID),
			slog.Int64("duration_ms", duration.Milliseconds()),
		)
	}

	return result, nil
}

// Delete deletes a {{ .ModelName }}.
{{- if .SoftDeletes }}
// Note: This performs a soft delete (sets deleted_at timestamp).
{{- end }}
func (r *{{ .ModelName }}RepositoryBase) Delete(ctx context.Context, id {{ .PrimaryKeyType }}) error {
	start := time.Now()

	err := r.queries.Delete{{ .ModelName }}(ctx, id)

	duration := time.Since(start)

	if err != nil {
		r.logger.ErrorContext(ctx, "failed to delete {{ .ModelName }}",
			slog.String("layer", "repository"),
			slog.String("operation", "Delete"),
			slog.Any("id", id),
			slog.String("error", err.Error()),
			slog.Int64("duration_ms", duration.Milliseconds()),
		)
		return err
	}

	if duration.Milliseconds() > 100 {
		r.logger.WarnContext(ctx, "slow query detected",
			slog.String("layer", "repository"),
			slog.String("operation", "Delete"),
			slog.String("model", "{{ .ModelName }}"),
			slog.Any("id", id),
			slog.Int64("duration_ms", duration.Milliseconds()),
		)
	}

	return nil
}
{{- if .SoftDeletes }}

// Restore restores a soft-deleted {{ .ModelName }}.
func (r *{{ .ModelName }}RepositoryBase) Restore(ctx context.Context, id {{ .PrimaryKeyType }}) error {
	start := time.Now()

	err := r.queries.Restore{{ .ModelName }}(ctx, id)

	duration := time.Since(start)

	if err != nil {
		r.logger.ErrorContext(ctx, "failed to restore {{ .ModelName }}",
			slog.String("layer", "repository"),
			slog.String("operation", "Restore"),
			slog.Any("id", id),
			slog.String("error", err.Error()),
			slog.Int64("duration_ms", duration.Milliseconds()),
		)
		return err
	}

	if duration.Milliseconds() > 100 {
		r.logger.WarnContext(ctx, "slow query detected",
			slog.String("layer", "repository"),
			slog.String("operation", "Restore"),
			slog.String("model", "{{ .ModelName }}"),
			slog.Any("id", id),
			slog.Int64("duration_ms", duration.Milliseconds()),
		)
	}

	return nil
}
{{- end }}

// WithTx executes a function within a database transaction.
// If the function returns an error, the transaction is rolled back.
// If the function panics, the transaction is rolled back and the panic is re-raised.
// Otherwise, the transaction is committed.
//
// Example:
//   err := repo.WithTx(ctx, func(txRepo {{ .ModelName }}Repository) error {
//       _, err := txRepo.Create(ctx, createParams)
//       if err != nil {
//           return err
//       }
//       // More operations...
//       return nil
//   })
func (r *{{ .ModelName }}RepositoryBase) WithTx(ctx context.Context, fn func({{ .ModelName }}Repository) error) error {
	// Begin transaction
	tx, err := r.db.Begin(ctx)
	if err != nil {
		return fmt.Errorf("begin transaction: %w", err)
	}

	// Create new queries instance bound to transaction
	txQueries := r.queries.WithTx(tx)

	// Create new repository instance with transaction-bound queries
	txRepo := &{{ .ModelName }}Repository{
		{{ .ModelName }}RepositoryBase: {{ .ModelName }}RepositoryBase{
			queries: txQueries,
			db:      r.db,
			logger:  r.logger,
		},
	}

	// Handle panic and errors with proper cleanup
	var fnErr error
	defer func() {
		if p := recover(); p != nil {
			// Rollback on panic
			_ = tx.Rollback()
			panic(p) // Re-raise panic
		} else if fnErr != nil {
			// Rollback on error
			_ = tx.Rollback()
		} else {
			// Commit on success
			fnErr = tx.Commit()
			if fnErr != nil {
				fnErr = fmt.Errorf("commit transaction: %w", fnErr)
			}
		}
	}()

	// Execute function
	fnErr = fn(txRepo)
	return fnErr
}
{{- if .Relationships }}

// ==========================================
// Relationship Loading Methods
// ==========================================
{{- range .Relationships }}

{{- if .IsSingle }}
// {{ .LoadMethod }} loads the related {{ .Model }} for this {{ $.ModelName }}.
func (r *{{ $.ModelName }}RepositoryBase) {{ .LoadMethod }}(ctx context.Context, entity *db.{{ $.ModelName }}) (*{{ .ModelType }}, error) {
	start := time.Now()

	result, err := r.queries.{{ .GetQueryName }}(ctx, entity.{{ .ForeignKeyField }})

	duration := time.Since(start)

	if err != nil && err != sql.ErrNoRows {
		r.logger.ErrorContext(ctx, "failed to load {{ .Name }}",
			slog.String("layer", "repository"),
			slog.String("operation", "{{ .LoadMethod }}"),
			slog.Any("{{ $.ModelName | lower }}_id", entity.ID),
			slog.String("error", err.Error()),
			slog.Int64("duration_ms", duration.Milliseconds()),
		)
		return nil, err
	}

	if duration.Milliseconds() > 100 {
		r.logger.WarnContext(ctx, "slow query detected",
			slog.String("layer", "repository"),
			slog.String("operation", "{{ .LoadMethod }}"),
			slog.String("model", "{{ $.ModelName }}"),
			slog.Int64("duration_ms", duration.Milliseconds()),
		)
	}

	if err == sql.ErrNoRows {
		return nil, nil
	}

	return &result, nil
}
{{- end }}

{{- if .IsMany }}
// {{ .LoadMethod }} loads all related {{ .Model }}s for this {{ $.ModelName }}.
func (r *{{ $.ModelName }}RepositoryBase) {{ .LoadMethod }}(ctx context.Context, entity *db.{{ $.ModelName }}) ([]{{ .ModelType }}, error) {
	start := time.Now()

	result, err := r.queries.{{ .GetQueryName }}(ctx, entity.ID)

	duration := time.Since(start)

	if err != nil {
		r.logger.ErrorContext(ctx, "failed to load {{ .Name }}",
			slog.String("layer", "repository"),
			slog.String("operation", "{{ .LoadMethod }}"),
			slog.Any("{{ $.ModelName | lower }}_id", entity.ID),
			slog.String("error", err.Error()),
			slog.Int64("duration_ms", duration.Milliseconds()),
		)
		return nil, err
	}

	if duration.Milliseconds() > 100 {
		r.logger.WarnContext(ctx, "slow query detected",
			slog.String("layer", "repository"),
			slog.String("operation", "{{ .LoadMethod }}"),
			slog.String("model", "{{ $.ModelName }}"),
			slog.Int64("duration_ms", duration.Milliseconds()),
		)
	}

	return result, nil
}

// {{ .LoadManyMethod }} batch loads {{ .Model }}s for multiple {{ $.ModelName }}s.
// Returns a map keyed by {{ $.ModelName }} ID for easy association.
func (r *{{ $.ModelName }}RepositoryBase) {{ .LoadManyMethod }}(ctx context.Context, entities []db.{{ $.ModelName }}) (map[{{ .ForeignKeyType }}][]{{ .ModelType }}, error) {
	if len(entities) == 0 {
		return make(map[{{ .ForeignKeyType }}][]{{ .ModelType }}), nil
	}

	start := time.Now()

	// Extract IDs
	ids := make([]{{ .ForeignKeyType }}, len(entities))
	for i, entity := range entities {
		ids[i] = entity.ID
	}

	// Batch query
	results, err := r.queries.{{ .GetManyQueryName }}(ctx, ids)

	duration := time.Since(start)

	if err != nil {
		r.logger.ErrorContext(ctx, "failed to batch load {{ .Name }}",
			slog.String("layer", "repository"),
			slog.String("operation", "{{ .LoadManyMethod }}"),
			slog.Int("entity_count", len(entities)),
			slog.String("error", err.Error()),
			slog.Int64("duration_ms", duration.Milliseconds()),
		)
		return nil, err
	}

	if duration.Milliseconds() > 100 {
		r.logger.WarnContext(ctx, "slow query detected",
			slog.String("layer", "repository"),
			slog.String("operation", "{{ .LoadManyMethod }}"),
			slog.String("model", "{{ $.ModelName }}"),
			slog.Int("entity_count", len(entities)),
			slog.Int64("duration_ms", duration.Milliseconds()),
		)
	}

	// Group by foreign key
	grouped := make(map[{{ .ForeignKeyType }}][]{{ .ModelType }})
	for _, result := range results {
		fk := result.{{ .ForeignKeyField }}
		grouped[fk] = append(grouped[fk], result)
	}

	return grouped, nil
}
{{- end }}

{{- end }}
{{- end }}
{{- if .HasAPILoadableRelationships }}

// ==========================================
// Relationship Validation
// ==========================================

// ValidateIncludes checks if requested includes are allowed by schema.
// Only relationships with api_loadable: true can be loaded via API.
// Returns an error if any requested relationship is not API loadable.
func (r *{{ .ModelName }}RepositoryBase) ValidateIncludes(includes []string) error {
	if len(includes) == 0 {
		return nil
	}

	// Whitelist generated from schema (only relationships with api_loadable: true)
	allowed := map[string]bool{
{{- range .Relationships }}
{{- if .APILoadable }}
		"{{ .Name | lower }}": true,
{{- end }}
{{- end }}
	}

	for _, inc := range includes {
		// Normalize to lowercase for case-insensitive matching
		normalized := strings.ToLower(strings.TrimSpace(inc))
		if normalized == "" {
			continue
		}

		if !allowed[normalized] {
			return fmt.Errorf("relationship '%s' is not available for API loading", inc)
		}
	}

	return nil
}
{{- end }}
