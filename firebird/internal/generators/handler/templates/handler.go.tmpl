// Code generated by Firebird. Edit freely - this file is yours.
package handlers

import (
	"encoding/json"
	"net/http"

	"{{ .ModulePath }}/internal/dto"
	apperrors "{{ .ModulePath }}/internal/errors"
	"{{ .ModulePath }}/internal/helpers"
	"{{ .ModulePath }}/internal/services"
	"{{ .ModulePath }}/internal/validation"
{{- if eq .PrimaryKeyType "uuid.UUID" }}
	"github.com/google/uuid"
{{- end }}
)

// {{ .ModelName }}Handler handles HTTP requests for {{ .ModelName }} resources
type {{ .ModelName }}Handler struct {
	service   services.{{ .ModelName }}Service
	validator *validation.Validate
}

// New{{ .ModelName }}Handler creates a new {{ .ModelName }} handler
func New{{ .ModelName }}Handler(service services.{{ .ModelName }}Service) *{{ .ModelName }}Handler {
	return &{{ .ModelName }}Handler{
		service:   service,
		validator: validation.New(),
	}
}

// Index handles GET /{{ .ModelPlural }} - List all {{ .ModelPlural }} with pagination, sorting, and filtering
// Query params: ?page=1&per_page=20&sort=-created_at&status=published&q=search
func (h *{{ .ModelName }}Handler) Index(w http.ResponseWriter, r *http.Request) {
	// Parse pagination
	pagination := helpers.ParsePagination(r.URL.Query())

	// Parse sorting (example allowed fields)
	// allowedSorts := []string{"id", "created_at", "updated_at", "title"}
	// sortOrders := helpers.ParseSort(r.URL.Query().Get("sort"), allowedSorts)

	// Parse filters (example allowed filters)
	// allowedFilters := map[string]string{
	//     "status": "=",
	//     "author_id": "=",
	// }
	// filters := helpers.ParseFilters(r.URL.Query(), allowedFilters)

	// Parse search
	// searchFields := []string{"title", "content"}
	// search := helpers.ParseSearch(r.URL.Query(), searchFields)

	// For now, use basic pagination
	// TODO: Extend service layer to support sorting, filtering, and search
	result, err := h.service.List(r.Context(), pagination)
	if err != nil {
		helpers.RespondError(w, err)
		return
	}

	meta := map[string]interface{}{
		"page":        result.Page,
		"per_page":    result.PerPage,
		"total":       result.Total,
		"total_pages": result.TotalPages,
	}

	response := map[string]interface{}{
		"data": result.Items,
		"meta": meta,
	}

	helpers.RespondSuccess(w, response)
}

// Store handles POST /{{ .ModelPlural }} - Create new {{ .ModelNameLower }}
func (h *{{ .ModelName }}Handler) Store(w http.ResponseWriter, r *http.Request) {
	var req dto.Create{{ .ModelName }}Input
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		helpers.RespondError(w, apperrors.NewBadRequestError("Invalid JSON"))
		return
	}

	// Validate input
	if err := helpers.ValidateStruct(&req); err != nil {
		validationErrs := helpers.ValidationErrorResponse(err)
		helpers.RespondError(w, apperrors.NewValidationError("Validation failed", map[string]interface{}{
			"fields": validationErrs,
		}))
		return
	}

	{{ .ModelNameLower }}, err := h.service.Create(r.Context(), req)
	if err != nil {
		helpers.RespondError(w, err)
		return
	}

	helpers.RespondCreated(w, {{ .ModelNameLower }})
}

// Show handles GET /{{ .ModelPlural }}/{id} - Get single {{ .ModelNameLower }}
{{- if .HasAPILoadableRelationships }}
// Supports ?include=relationship1,relationship2 for eager loading
{{- end }}
func (h *{{ .ModelName }}Handler) Show(w http.ResponseWriter, r *http.Request) {
	id, err := GetPath{{ if eq .PrimaryKeyType "uuid.UUID" }}UUID{{ else }}Int64{{ end }}(r, "id")
	if err != nil {
		helpers.RespondError(w, apperrors.NewBadRequestError("Invalid ID format"))
		return
	}

{{- if .HasAPILoadableRelationships }}
	// Check for relationship includes
	includes := ParseIncludes(r)

	var {{ .ModelNameLower }} *dto.{{ .ModelName }}Response
	if len(includes) > 0 {
		{{ .ModelNameLower }}, err = h.service.GetByIDWithIncludes(r.Context(), id, includes)
	} else {
		{{ .ModelNameLower }}, err = h.service.GetByID(r.Context(), id)
	}

	if err != nil {
		helpers.RespondError(w, err)
		return
	}
{{- else }}
	{{ .ModelNameLower }}, err := h.service.GetByID(r.Context(), id)
	if err != nil {
		helpers.RespondError(w, err)
		return
	}
{{- end }}

	helpers.RespondSuccess(w, {{ .ModelNameLower }})
}

// Update handles PUT /{{ .ModelPlural }}/{id} - Update {{ .ModelNameLower }}
func (h *{{ .ModelName }}Handler) Update(w http.ResponseWriter, r *http.Request) {
	id, err := GetPath{{ if eq .PrimaryKeyType "uuid.UUID" }}UUID{{ else }}Int64{{ end }}(r, "id")
	if err != nil {
		helpers.RespondError(w, apperrors.NewBadRequestError("Invalid ID format"))
		return
	}

	var req dto.Update{{ .ModelName }}Input
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		helpers.RespondError(w, apperrors.NewBadRequestError("Invalid JSON"))
		return
	}

	// Validate input
	if err := helpers.ValidateStruct(&req); err != nil {
		validationErrs := helpers.ValidationErrorResponse(err)
		helpers.RespondError(w, apperrors.NewValidationError("Validation failed", map[string]interface{}{
			"fields": validationErrs,
		}))
		return
	}

	{{ .ModelNameLower }}, err := h.service.Update(r.Context(), id, req)
	if err != nil {
		helpers.RespondError(w, err)
		return
	}

	helpers.RespondSuccess(w, {{ .ModelNameLower }})
}

// Destroy handles DELETE /{{ .ModelPlural }}/{id} - {{ if .HasSoftDelete }}Soft delete{{ else }}Delete{{ end }} {{ .ModelNameLower }}
func (h *{{ .ModelName }}Handler) Destroy(w http.ResponseWriter, r *http.Request) {
	id, err := GetPath{{ if eq .PrimaryKeyType "uuid.UUID" }}UUID{{ else }}Int64{{ end }}(r, "id")
	if err != nil {
		helpers.RespondError(w, apperrors.NewBadRequestError("Invalid ID format"))
		return
	}

{{ if .HasSoftDelete }}	// Soft delete (sets deleted_at timestamp)
{{ end }}	err = h.service.Delete(r.Context(), id)
	if err != nil {
		helpers.RespondError(w, err)
		return
	}

	helpers.RespondNoContent(w)
}

// TODO: Add custom handlers here
// Example:
//
// func (h *{{ .ModelName }}Handler) CustomAction(w http.ResponseWriter, r *http.Request) {
//     // Your custom handler logic
// }
