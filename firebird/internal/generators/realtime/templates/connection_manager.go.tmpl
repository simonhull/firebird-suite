// Code generated by Firebird. DO NOT EDIT.

package realtime

import (
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"sync"
	"time"

	"github.com/google/uuid"
	"github.com/gorilla/websocket"
	"{{ .ModulePath }}/internal/events"
)

// Connection represents a WebSocket client connection
type Connection struct {
	ID            string
	Conn          *websocket.Conn
	Send          chan []byte
	Manager       *ConnectionManager
	Subscriptions map[string]bool
	Metadata      map[string]interface{}
	mu            sync.RWMutex
}

// ConnectionManager manages all active WebSocket connections
type ConnectionManager struct {
	connections map[string]*Connection
	eventBus    events.EventBus
	presence    *PresenceManager
	rooms       *RoomManager
	logger      *slog.Logger
	mu          sync.RWMutex
}

// NewConnectionManager creates a new connection manager
func NewConnectionManager(eventBus events.EventBus, logger *slog.Logger) *ConnectionManager {
	return &ConnectionManager{
		connections: make(map[string]*Connection),
		eventBus:    eventBus,
		presence:    NewPresenceManager(eventBus, logger),
		rooms:       NewRoomManager(logger),
		logger:      logger,
	}
}

// Presence returns the presence manager
func (cm *ConnectionManager) Presence() *PresenceManager {
	return cm.presence
}

// Rooms returns the room manager
func (cm *ConnectionManager) Rooms() *RoomManager {
	return cm.rooms
}

// Register adds a new connection
func (cm *ConnectionManager) Register(conn *websocket.Conn) *Connection {
	cm.mu.Lock()
	defer cm.mu.Unlock()

	connection := &Connection{
		ID:            uuid.New().String(),
		Conn:          conn,
		Send:          make(chan []byte, 256),
		Manager:       cm,
		Subscriptions: make(map[string]bool),
		Metadata:      make(map[string]interface{}),
	}

	cm.connections[connection.ID] = connection

	cm.logger.Info("connection registered",
		slog.String("connection_id", connection.ID),
		slog.Int("total_connections", len(cm.connections)),
	)

	return connection
}

// Unregister removes a connection
func (cm *ConnectionManager) Unregister(connection *Connection) {
	cm.mu.Lock()
	defer cm.mu.Unlock()

	if _, exists := cm.connections[connection.ID]; exists {
		delete(cm.connections, connection.ID)
		close(connection.Send)

		// Unsubscribe from all topics
		for topic := range connection.Subscriptions {
			cm.eventBus.Unsubscribe(topic)
		}

		cm.logger.Info("connection unregistered",
			slog.String("connection_id", connection.ID),
			slog.Int("total_connections", len(cm.connections)),
		)
	}
}

// Subscribe adds a topic subscription for this connection
func (c *Connection) Subscribe(ctx context.Context, topic string) error {
	c.mu.Lock()
	defer c.mu.Unlock()

	if c.Subscriptions[topic] {
		return nil // Already subscribed
	}

	// Subscribe to event bus
	eventChan, err := c.Manager.eventBus.Subscribe(ctx, topic)
	if err != nil {
		return err
	}

	c.Subscriptions[topic] = true

	// Forward events to WebSocket
	go c.forwardEvents(eventChan, topic)

	c.Manager.logger.InfoContext(ctx, "connection subscribed",
		slog.String("connection_id", c.ID),
		slog.String("topic", topic),
	)

	return nil
}

// Unsubscribe removes a topic subscription
func (c *Connection) Unsubscribe(topic string) error {
	c.mu.Lock()
	defer c.mu.Unlock()

	if !c.Subscriptions[topic] {
		return nil
	}

	delete(c.Subscriptions, topic)

	if err := c.Manager.eventBus.Unsubscribe(topic); err != nil {
		return err
	}

	c.Manager.logger.Info("connection unsubscribed",
		slog.String("connection_id", c.ID),
		slog.String("topic", topic),
	)

	return nil
}

// forwardEvents listens to event bus and sends to WebSocket
func (c *Connection) forwardEvents(eventChan <-chan events.Event, topic string) {
	for event := range eventChan {
		// Check if still subscribed
		c.mu.RLock()
		subscribed := c.Subscriptions[topic]
		c.mu.RUnlock()

		if !subscribed {
			return
		}

		// Marshal event
		data, err := json.Marshal(event)
		if err != nil {
			c.Manager.logger.Error("failed to marshal event",
				slog.String("error", err.Error()),
			)
			continue
		}

		// Send to connection
		select {
		case c.Send <- data:
		case <-time.After(5 * time.Second):
			c.Manager.logger.Warn("send timeout, closing connection",
				slog.String("connection_id", c.ID),
			)
			c.Manager.Unregister(c)
			return
		}
	}
}

// WritePump sends messages from the hub to the websocket connection
func (c *Connection) WritePump() {
	ticker := time.NewTicker(54 * time.Second) // Ping every 54s
	defer func() {
		ticker.Stop()
		c.Conn.Close()
	}()

	for {
		select {
		case message, ok := <-c.Send:
			c.Conn.SetWriteDeadline(time.Now().Add(10 * time.Second))
			if !ok {
				// Channel closed
				c.Conn.WriteMessage(websocket.CloseMessage, []byte{})
				return
			}

			if err := c.Conn.WriteMessage(websocket.TextMessage, message); err != nil {
				return
			}

		case <-ticker.C:
			c.Conn.SetWriteDeadline(time.Now().Add(10 * time.Second))
			if err := c.Conn.WriteMessage(websocket.PingMessage, nil); err != nil {
				return
			}
		}
	}
}

// ReadPump reads messages from the websocket connection
func (c *Connection) ReadPump() {
	defer func() {
		c.Manager.Unregister(c)
		c.Conn.Close()
	}()

	c.Conn.SetReadDeadline(time.Now().Add(60 * time.Second))
	c.Conn.SetPongHandler(func(string) error {
		c.Conn.SetReadDeadline(time.Now().Add(60 * time.Second))
		return nil
	})

	for {
		_, message, err := c.Conn.ReadMessage()
		if err != nil {
			if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
				c.Manager.logger.Error("websocket error",
					slog.String("error", err.Error()),
				)
			}
			break
		}

		// Handle incoming message
		if err := c.handleMessage(message); err != nil {
			c.Manager.logger.Error("failed to handle message",
				slog.String("error", err.Error()),
			)
		}
	}
}

// ClientMessage represents message types from client
type ClientMessage struct {
	Action string                 `json:"action"` // "subscribe", "unsubscribe", "publish", "join", "leave", "track"
	Topic  string                 `json:"topic"`
	Data   map[string]interface{} `json:"data,omitempty"`
}

// handleMessage processes messages from the client
func (c *Connection) handleMessage(message []byte) error {
	var msg ClientMessage
	if err := json.Unmarshal(message, &msg); err != nil {
		return err
	}

	ctx := context.Background()

	switch msg.Action {
	case "subscribe":
		return c.Subscribe(ctx, msg.Topic)
	case "unsubscribe":
		return c.Unsubscribe(msg.Topic)
	case "join":
		// Join a room
		return c.Manager.rooms.Join(msg.Topic, c)
	case "leave":
		// Leave a room
		return c.Manager.rooms.Leave(msg.Topic, c.ID)
	case "track":
		// Track presence
		userID, _ := msg.Data["user_id"].(string)
		metadata, _ := msg.Data["metadata"].(map[string]interface{})
		return c.Manager.presence.Track(ctx, msg.Topic, userID, c.ID, metadata)
	case "publish":
		// Optional: Allow clients to publish events
		// Add authentication/authorization checks here
		return c.Manager.eventBus.Publish(ctx, msg.Topic, msg.Data)
	default:
		return fmt.Errorf("unknown action: %s", msg.Action)
	}
}

// Broadcast sends a message to all connections subscribed to a topic
func (cm *ConnectionManager) Broadcast(ctx context.Context, topic string, data interface{}) error {
	return cm.eventBus.Publish(ctx, topic, data)
}

// GetConnection returns a connection by ID
func (cm *ConnectionManager) GetConnection(id string) (*Connection, bool) {
	cm.mu.RLock()
	defer cm.mu.RUnlock()
	conn, exists := cm.connections[id]
	return conn, exists
}

// ConnectionCount returns the number of active connections
func (cm *ConnectionManager) ConnectionCount() int {
	cm.mu.RLock()
	defer cm.mu.RUnlock()
	return len(cm.connections)
}
