// Code generated by Firebird. Edit freely - this file is yours.
package handlers

import (
	"encoding/json"
	"errors"
	"net/http"

	"github.com/go-playground/validator/v10"
	"{{ .ModulePath }}/internal/services"
)

// SuccessResponse wraps successful responses
type SuccessResponse struct {
	Data interface{} `json:"data"`
	Meta interface{} `json:"meta,omitempty"`
}

// ErrorResponse wraps error responses
type ErrorResponse struct {
	Error ErrorDetail `json:"error"`
}

// ErrorDetail contains error information
type ErrorDetail struct {
	Message string                  `json:"message"`
	Code    string                  `json:"code"`
	Details []ValidationErrorDetail `json:"details,omitempty"`
}

// ValidationErrorDetail contains field-level validation errors
type ValidationErrorDetail struct {
	Field   string `json:"field"`
	Message string `json:"message"`
}

// RespondJSON writes a JSON response
func RespondJSON(w http.ResponseWriter, status int, data interface{}) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if err := json.NewEncoder(w).Encode(data); err != nil {
		// Log encoding error but don't expose to client
		http.Error(w, "Internal server error", http.StatusInternalServerError)
	}
}

// RespondSuccess writes a successful JSON response
func RespondSuccess(w http.ResponseWriter, status int, data interface{}) {
	RespondJSON(w, status, SuccessResponse{
		Data: data,
	})
}

// RespondSuccessWithMeta writes a successful JSON response with metadata
func RespondSuccessWithMeta(w http.ResponseWriter, status int, data interface{}, meta interface{}) {
	RespondJSON(w, status, SuccessResponse{
		Data: data,
		Meta: meta,
	})
}

// RespondError writes an error JSON response
func RespondError(w http.ResponseWriter, status int, message string, code string) {
	RespondJSON(w, status, ErrorResponse{
		Error: ErrorDetail{
			Message: message,
			Code:    code,
		},
	})
}

// RespondValidationError writes a validation error response
func RespondValidationError(w http.ResponseWriter, err error) {
	details := []ValidationErrorDetail{}

	if validationErrs, ok := err.(validator.ValidationErrors); ok {
		for _, e := range validationErrs {
			details = append(details, ValidationErrorDetail{
				Field:   e.Field(),
				Message: formatValidationMessage(e),
			})
		}
	}

	RespondJSON(w, http.StatusUnprocessableEntity, ErrorResponse{
		Error: ErrorDetail{
			Message: "Validation failed",
			Code:    "validation_error",
			Details: details,
		},
	})
}

// RespondServiceError maps service errors to HTTP responses
func RespondServiceError(w http.ResponseWriter, err error) {
	switch {
	case errors.Is(err, services.ErrNotFound):
		RespondError(w, http.StatusNotFound, "Resource not found", "not_found")
	case errors.Is(err, services.ErrInvalidInput):
		// Check if it's a validation error
		var validationErr *services.ValidationError
		if errors.As(err, &validationErr) {
			RespondValidationError(w, validationErr.Err)
			return
		}
		RespondError(w, http.StatusBadRequest, "Invalid input", "invalid_input")
	case errors.Is(err, services.ErrUnauthorized):
		RespondError(w, http.StatusUnauthorized, "Unauthorized", "unauthorized")
	case errors.Is(err, services.ErrForbidden):
		RespondError(w, http.StatusForbidden, "Forbidden", "forbidden")
	case errors.Is(err, services.ErrAlreadyExists):
		RespondError(w, http.StatusConflict, "Resource already exists", "already_exists")
	default:
		// Don't expose internal error details
		RespondError(w, http.StatusInternalServerError, "Internal server error", "internal_error")
	}
}

// formatValidationMessage converts validator tags to human-readable messages
func formatValidationMessage(e validator.FieldError) string {
	switch e.Tag() {
	case "required":
		return "is required"
	case "email":
		return "must be a valid email address"
	case "min":
		return "must be at least " + e.Param() + " characters"
	case "max":
		return "must be at most " + e.Param() + " characters"
	case "slug":
		return "must be a valid URL slug (lowercase letters, numbers, hyphens)"
	case "uuid":
		return "must be a valid UUID"
	default:
		return "is invalid"
	}
}

// TODO: Add custom response helpers here
// Example:
//
// func RespondCreated(w http.ResponseWriter, data interface{}, location string) {
//     w.Header().Set("Location", location)
//     RespondSuccess(w, http.StatusCreated, data)
// }
